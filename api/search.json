[{"id":"7a50ed205ba25f6b7085d462d38a3771","title":"mongoDB 資料庫（資料表操作）","content":"\n\n\n\n\n\nTIP\n關於 mongoDB 資料庫與資料表操作用自己的口語再次筆記練習\n\n前置操作（需要先安裝 MongoDB、Mongo Shell、MongoDB Compass）\n使用 mongod 開啟伺服器應用（資料庫）bashmongod --dbpath `db資料夾路徑` --logpath `log資料夾路徑`mongosh：造訪資料庫，並做一些應用（新增、刪除、修改…）bashmongosh\nshow dbs：呈現現有資料庫（一開始預設是三個）tsxshow dbsuse 來使用某個資料庫如果沒有這個資料庫，則會直接幫我們新增，並移動到這個資料庫\nbashuse `資料庫名稱`\n// use hotel\n資料表操作單筆、多筆資料(document)insert 相關insertOne 新增單筆資料： 在 posts 這個資料表中，新增一筆資料(document)，這筆資料有七個欄位（如果一開始沒有 posts 這個資料表，則會在輸入指令時幫我們新增）\nbashdb.posts.insertOne(&#123;\n    &quot;name&quot;:&quot;Billy&quot;,\n    &quot;image&quot;:&quot;https://dummyimage.com/248x100.png/dddddd/000000&quot;,\n    &quot;content&quot;:&quot;我是貼文內容，20240304新增&quot;,\n    &quot;likes&quot;:50,\n    &quot;comment&quot;:30,\n    &quot;type&quot;:&quot;group&quot;,\n    &quot;tags&quot;:[&quot;心情&quot;,&quot;教育&quot;],\n&#125;)insertMany 新增多筆資料：在 posts 這個資料表中，新增兩筆資料(document)，每筆資料有七個欄位\nbashdb.posts.insertMany([\n    &#123;\n    &quot;name&quot;:&quot;Billy2&quot;,\n    &quot;image&quot;:&quot;https://dummyimage.com/248x100.png/dddddd/000000&quot;,\n    &quot;content&quot;:&quot;我是貼文內容222，20240304新增&quot;,\n    &quot;likes&quot;:80,\n    &quot;comment&quot;:60,\n    &quot;type&quot;:&quot;group&quot;,\n    &quot;tags&quot;:[&quot;心情&quot;,&quot;教育&quot;],\n  &#125;,\n    &#123;\n    &quot;name&quot;:&quot;Billy3&quot;,\n    &quot;image&quot;:&quot;https://dummyimage.com/248x100.png/dddddd/000000&quot;,\n    &quot;content&quot;:&quot;我是貼文內容333，20240304新增&quot;,\n    &quot;likes&quot;:500,\n    &quot;comment&quot;:300,\n    &quot;type&quot;:&quot;group&quot;,\n    &quot;tags&quot;:[&quot;心情&quot;,&quot;教育&quot;],\n  &#125;\n])Update 相關updateOne 修改單筆資料：在 posts 這個資料表中，根據條件篩選出的一筆資料(document)，進行欄位的調整。下方範例是將篩選出的資料(document)，將 content 欄位的值調整為”測試資料”\nbashdb.posts.updateOne(\n    &#123;&quot;_id&quot;:ObjectId(&quot;xxxxxxxxx...&quot;)&#125;, // 條件篩選\n    &#123;$set:&#123;&quot;content&quot;:&quot;測試資料&quot;&#125;&#125;\n)篩選一筆特定資料(document)，將裡頭的 tags 陣列欄位，再新增一個新 tags \nbashdb.posts.updateOne(\n&#123;&quot;_id&quot;:ObjectId(&quot;65dcxxx...&quot;)&#125;\n,&#123;$push:&#123;tags:&quot;遊記&quot;&#125;&#125;)\n\n// 驗證\n// db.posts.find(&#123; \n   // &quot;_id&quot;:ObjectId(&quot;65dcxxx...&quot;)\n// &#125;)\nupdateMany 修改多筆資料：在 posts 這個資料表中，去篩選出多筆 name 欄位為”abc123”的資料(document)，並將這些資料的 content 欄位都調整成”測試”\nbashdb.posts.updateMany(\n  &#123;&quot;name&quot;:&quot;abc123&quot;&#125;,\n  &#123;$set:&#123;&quot;content&quot;:&quot;測試&quot;&#125;&#125;\n)\n使用 updateMany 來移除欄位，下方範例是將 tags 陣列的”感情” tag 都移除\nbashdb.posts.updateMany(\n  &#123; &quot;tags&quot;: &quot;感情&quot; &#125;,\n  &#123; $pull: &#123; &quot;tags&quot;: &quot;感情&quot; &#125; &#125;\n)\ndelete 相關deleteOne 刪除單筆資料：在 posts 這個資料表中，去篩選 id 為 aaa123 的資料(document)，然後將之刪除\nbashdb.posts.deleteOne(\n  &#123;&quot;_id&quot;:ObjectId(&quot;aaa123&quot;)&#125;\n)\ndeleteMany 刪除多筆資料：將 type: group 這個條件中的多筆資料都刪除\nbashdb.posts.deleteMany(\n  &#123;\n    &quot;type&quot;:&quot;group&quot; // 條件\n  &#125;\n)\n多個條件：將名字為 abc，以及 likes 數量 500(含) 以下都刪除\nbashdb.posts.deleteMany(\n  &#123;\n    &quot;name&quot;:&quot;abc&quot;,\n    &quot;likes&quot;:&#123;\n      $lte: 500 // $lte 表示小於等於\n    &#125;\n  &#125;\n)\n不寫任何條件，等同於刪除全部資料\nbashdb.posts.deleteMany(&#123;&#125;)find 相關查詢全部 posts 的資料列表(document) \nbashdb.posts.find()\ndb.posts.find().pretty()模糊搜尋：name 欄位含有 o 的資料列表\nbashdb.posts.find(\n  &#123;&quot;name&quot;:/o/&#125;\n)\n單個條件：查詢 comments 有大於等於 500 以上的資料列表\nbashdb.posts.find(\n  &#123;\n    &quot;comments&quot;: &#123;\n        $gte:500\n    &#125;,\n  &#125;\n)\n查詢 image 欄位為 null 的資料列表\nbashdb.posts.find(&#123;\n  &quot;image&quot;: null\n&#125;)\n多個條件：name 欄位為 abc123，按讚數大於等於 500、小於等於 1000\nbashdb.posts.find(\n  &#123;\n    &quot;name&quot;: &quot;abc123&quot;,\n    &quot;likes&quot;: &#123;\n        $gte:500, // $gte 大於等於\n        $lte:1000 // $lte 小於等於\n    &#125;,\n  &#125;\n)project 保護欄位：查詢 tags 欄位中，有包含到”幹話”的資料列表，然後將 _id 欄位設置隱藏（在有些狀況中，我們不可透露重要資訊在 user）\nbashdb.posts.find(\n  &#123;\n    &quot;tags&quot;: &#123;\n      $in: [&#39;幹話&#39;] // $in 表示內容存在某個值\n    &#125;\n  &#125;,\n  &#123;&quot;_id&quot;: 0&#125; // 將 id 欄位隱藏\n)\n查詢 tags 欄位，有 謎因 或(or) 幹話 的資料列表\nbashdb.posts.find(\n  &#123;\n    &quot;tags&quot;: &#123;\n      $in: [&#39;謎因&#39;,&#39;幹話&#39;]\n    &#125;\n  &#125;\n)\nfind 的 $and 與 $or：在 posts 資料表中，找尋 likes 跟(and) comments 欄位都大於等於 1500 以上的資料列表（參考連結）\nbashdb.posts.find(&#123;\n  $and: [\n    &#123; &quot;likes&quot;: &#123; $gte: 1500 &#125; &#125;,\n    &#123; &quot;comments&quot;: &#123; $gte: 1500 &#125; &#125;\n  ]\n&#125;)\n\n//db.posts.find(&#123; 這個範例也可以這樣寫\n  //&quot;likes&quot;: &#123; $gte: 1500 &#125;,\n  //&quot;comments&quot;: &#123; $gte: 1500 &#125;\n//&#125;)在 posts 資料表中，找尋 likes 或(or) comments 欄位中，大於等於 1000 以上的資料列表\nbashdb.posts.find(&#123;\n  $or: [\n    &#123; &quot;likes&quot;: &#123; $gte: 1000 &#125; &#125;,\n    &#123; &quot;comments&quot;: &#123; $gte: 1000 &#125; &#125;\n  ]\n&#125;)\n顯示 posts 資料表的資料筆數（數字）（參考連結）\nbashdb.posts.countDocuments()查詢 name 欄位為 abc123 的資料列表，而這個排序從新到舊（參考連結）\nbashdb.posts.find(\n  &#123; &quot;name&quot;: &quot;abc123&quot; &#125; // 查詢條件\n).sort(\n  &#123; &quot;createdAt&quot;: -1 &#125; // 根據 createdAt 欄位進行降序排序 (由新到舊)\n)\n查詢 name 欄位為 abc123 的資料列表，只顯示前 30 筆資料（參考連結）\nbashdb.posts.find(\n  &#123; &quot;name&quot;: &quot;abc123&quot; &#125; // 查詢條件\n).limit(30) // 限制返回結果為前 30 筆資料\n查詢 name 欄位為 abc123、likes 欄位大於等於 100 的資料列表。而這個資料列表只需顯示前 30 筆，並且對於這資料列表做新到舊的排序\nbashdb.posts.find(\n  &#123; // 條件\n    &quot;name&quot;: &quot;abc123&quot;,\n    &quot;likes&quot;: &#123;\n        $gte:100,\n    &#125;\n  &#125;\n).limit(30).sort( &#123;&quot;createdAt&quot;: -1&#125; ); // 筆數與排序\n查詢 comments 超過 100 的資料列表，取得時先跳過前 30 筆資料，再顯示 30 筆資料\nbashdb.posts.find(\n  &#123;\n    &quot;comments&quot;: &#123;\n        $gt: 100\n    &#125;\n  &#125;\n).skip(30).limit(30); // 要 30 筆，但先跳過 30 筆replace 相關替換 replaceOne、replaceMany：如下範例，透過 id 篩選了一筆要 replace 的資料，這邊會將 name 欄位修改成 yes~。假設這筆資料還有其它欄位的話，在 replace 更新未寫到時，則會視為欄位的刪除，也就是這筆資料會只剩下 id 跟 name 欄位。（replace 這樣的用法也有刪除的功能）\nbashdb.posts.replaceOne(\n&#123;&quot;_id&quot;:ObjectId(&quot;abcxxx&quot;)&#125;,\n&#123;name:&quot;yes~&quot;&#125;)Comparison Query Operators 表格\n\n\n\n$eq\n等於\n\n\n\n$ne\n不等於\n\n\n$gt\n大於\n\n\n$lt\n小於\n\n\n$gte\n大於等於\n\n\n$lte\n小於等於\n\n\n$in\n存在某個值\n\n\n$nin\n不存在某個值\n\n\n","slug":"mongod-mongosh","date":"2024-03-10T12:51:16.000Z","categories_index":"前端","tags_index":"MongoDB,Mongo Shell","author_index":"Billy's blog"},{"id":"6e627d94fd2e3ea51fe1d3e3b1903242","title":"即將到來的 2024 隨筆","content":"\n圖片是用 AI 產出的，當我用 2023 to 2024 這個關鍵字時，它產了一張貓咪圖給我，某方面來說真的有點專業？然後就很乾脆（隨便）加上 2024 的文字作為封面了～\n內容真的是很隨筆，所以並沒有太多著墨在通順部分，以及內容可能有些怪力亂神，但已經盡量減少，還請見諒。預祝大家 2024 新年快樂～\n似乎有股看不見得力量，在引導跟安排攤開這兩年的經歷中，每段時間就像被設立一個關卡，在沒有真正從關卡領悟時（破關），這個關卡會不斷的重覆，直到能靜下來沈澱領悟，意識到自己舊有負面慣性。然後幸運的事情是，在每個關卡中，都會遇到一個引導者，在這點上覺得自己是很幸運的。題外話：這些引導者都有幾個共同點：價值觀中性、引導但不介入、真誠。\n課題分離與覺察先說個覺察部分，這是我不斷在生活中實行，才有一些些進步，偶爾一樣被情緒帶走，但陷入情緒漩渦已經越來越少。ex：\n\n爭執時回頭探索自己，很多時候的爭執都是來自過去經歷\n對於別人的期望、強烈情緒，會很快感覺到疲倦（目前探索中）\n負面想法、念頭增加時，能意識到自己給自己太多壓力、任務，應對方式就是暫時放空耍廢\n\n而課題分離是我今年在學習的，一個是立下自己界線，勇於拒絕，而另一個是不要去介入別人界線，錯把別人的功課當作是自己的功課。但實作起來真的不容易…\n說話的兩個卡點從生活上的溝通經驗中，我覺得溝通不是很容易（恩…真他x不容易），也充滿著藝術。一個卡點是說話不通暢，會覺得自己很常無法聚焦，因此說出口的話變得發散，有時則是腦袋有想法，但似乎不能好好表達，目前尚在探索原因是什麼。（求解惑）  \n第二個卡點則是說出口的想法跟立場，即使重覆 N 次，也不一定能進對方耳朵。有時對於這樣的狀況，我會覺得相當疲倦、生氣；但這陣子也許快抓到破關邊緣（應該吧… XD），我先想到每個人的經歷不同，100 個人看同一件 A 事物，就會產生 100 件不同的 A 事物、100 個認知世界，也會因為經歷而決定一些個人價值觀。接著延伸的想，也許我不一定對，如果我表達出來，對方就要認同、接受，那也不表示我試圖控制對方？  \n額外想說：自己目前的某結論，如果在談話中，發現價值觀差異太多，其實不需要勉強雙方，而僵持跟執著在這。嘗試逃跑、避開以及減少談論，也是一種方式。逃避不可恥，有時也很有用的\n關於12 月的諮詢（看診）在今年約秋季時，隨著身體不斷恢復，我也做出更多調整、嘗試，像是飲食調整，以及預約了呂博士諮詢、真吾的徐醫師看診。而這兩個預約很剛好的都在 12 月，且只相隔一週。\n在跟呂博士諮詢時，透過儀器檢測以及她的專業（自然醫學、營養學），讓我更確定目前的飲食調整是 OK 的方向，而且可以再更優化，像是碳水可以再更少。也收到博士的鼓勵，真的很感謝她！\n再來是真吾的徐醫師看診，大約在去年看中醫時，中醫師就有建議我可以去嘗試，因為我的狀況已經不是一般的身體因素。不過剛開始只知道徐醫師有在高雄、台中看診，加上那時我的狀態太差，所以就沒有去預約；待今年的一些因緣際會下，得知到目前也有在台北看診，於是就速速預約。原本就對真吾法有興趣，所以很想去體驗看看，什麼是與身體溝通，以及共同靜坐等。實際看診後，這是一個相當神奇的體驗，也得到了一些答案，而這些是目前將近兩年以來，最貼近內心深處的答案「我到底怎麼了？」（這邊僅略略分享，目前觀察期不細說，二來是也很挑人說，畢竟對於著重科學氛圍的現今社會，這會被歸類在怪力亂神類，但這些種種確實是發生了。）\n其他這邊留一些想寫的細項：\n\n期望自己已經在疑難雜症的破關結尾，這兩年的經驗真是不容易，不論對於自己或家人來說都是。\n學習在很多場景都放鬆，這需要很多的自我覺察，目前想達到連在工作狀態時都能是放鬆的。這種放鬆也讓我想到小時候學習新事物速度很快，就是夠專注且放鬆吧！\n決定來把頭髮留長，這幾年就一直都有這樣的衝動，目前仍在探索這隱含了什麼想法、觀念（也許是叛逆唷），反正就先留長，看看有沒有什麼想法冒出，又或者某一天就想要剪短了。  （對了，我會盡量讓自己看起來不邋遢拉，盡量…）\n\n","slug":"coming-2024","date":"2023-12-30T00:00:00.000Z","categories_index":"生活","tags_index":"生活,隨筆","author_index":"Billy's blog"},{"id":"39fce465be69f846db1f06abeac521ce","title":"32歲的重新探索，帶來什麼體會？","content":"\nPhoto by Emma Frances Logan on Unsplash\n\n四月的提問與轉折生活中常會有高低起伏，狀況好的時候，我可以很專注在能做且該做的事情上，甚至會有種淡淡的喜悅感；而狀況不好的時候，會比較容易受到負面念頭跟情緒的影響，冒出覺得很累、狀況好糟、為什麼要有這些體驗的種種想法。不過比起去年，我更能有意識的去覺察到這些種種，抱持著一種覺知，就比較容易跟負面保持距離（但不是要推開它）。即使偶爾被負面狀況帶走，回頭還是會告訴自己，這些高低起伏才是生活的真實寫照。\n在今年四月的時候，我每天都花上一段時間聽馬冠中醫師的讀書會，書籍是《開啟你的驚人天賦》。跟著馬醫師的讀書會，我開始省視起自己的思、言、行，開始對自己丟出疑問：\n\n為什麼會把自己弄到這般田地？\n為什麼會一直覺得好累？\n為什麼會覺得不快樂？\n為什麼我那麼努力、抱持積極的態度，卻好像沒達成什麼？\n是不是我過去的習慣、生活方式有問題？如果開始調整，是不是會產生不同結果？\n\n我想起了愛因斯坦曾經說：「什麼叫瘋子？就是重複做同樣的事情還期待會出現不同的結果」。而如果我一直用一樣的習慣、思、言、行，卻期望產生出不同結果，那我也是個瘋子吧！\n透過這些種種的疑問，讓我開始意識到不同的角度，也是一個轉折的開始。32 歲的這一年，才發現自己侷限在好多概念中，像是應該要、一定要如何，而忽略了其他的可能性，沒有來自好奇心的探索、自主思考與質疑，就好像在過一個別人所期望的人生。\n進一步探索的六月隨著四月的心境轉折，到了六月時，我開始探索起自己喜歡什麼，不過可能是過去很少這樣的探索，所以剛開始是腦袋一片空白的狀態（有一點沮喪）；不過在多方面探索嘗試後，漸漸浮出一些資訊。\n關於多方面的探索嘗試，我有用了這些方法：網路搜尋、閱讀相關書籍、回想過去事件、曾經聚焦過什麼領域、筆記本上的自問自答等等，以下也分享一些過程跟自我發現。\n曾經聚焦過的領域：\n\n極簡主義、整理相關\n數位游牧、自媒體\n寫作\nClean Deskup\n健身\n職涯與個人成長\n……\n\n問了自己什麼（自問自答的部分）：\n\n什麼樣的形容詞，可以拿來形容自己的特質？\n自己哪些層面很奇怪？即使有所自覺也沒打算調整的\n工作指派的開心與不開心？\n做什麼事情會覺得滿足？或有正向心情？\n……\n\n一些自我發現：\n\n比起一群人的熱鬧，我更喜歡 1~3 人做深入的聊天（談話）\n不喜歡體制，尤其是前人都這樣，所以就得這樣\n比想像中敏感，能讀懂一些空間氛圍，在人多的場合時，會下意識吸收一堆資訊（難怪我不喜歡人多的地方，因為會非常疲倦）\n偷渡一下自己的 MBTI，我是 INFJ\n……\n\n回顧機械系的小故事：  \n我在高職時讀了三年的板金科，而大學讀了四年的機械系，總共七年的工科背景。不過在回顧過去時，才發現自己很早就對機械領域沒什麼興趣，而且相性也不強，雖然那時都出現了一些**”訊號”**，不過大多都被我忽略跟壓抑下來，那些壓抑的因素大概有現實考量、不要給父母添麻煩、乖一點、不要那麼叛逆等等。關於訊號：\n\n唸書上還ＯＫ，但只要是實習課，即使付出相當努力，成效就是很差，常常看到機械製圖但腦袋一片空白。\n高職曾經有一段時間想轉科系。\n大學前期都窩在學校讀書館的哲學區，看了很多心理學相關，像是社會心理、認知相關、諮商等等，也想過轉到相關學校或科系。\n如果一直討論機械相關，其實我會覺得無聊跟倦怠。（如果是認識的工科同學來看，先說拍謝了，其實我覺得很無趣…XD）\n\n結尾在轉折跟探索中，發現自己被好多概念綁架，並固守在這些概念之中，如同上一段所提的小故事，過去在一些感受跟訊號出現時，自己就先限制自己（壓抑），而沒有勇氣採取進一步的探索跟體驗，沒有去嘗試自己更想貼近什麼。\n我很喜歡楊定一博士說的：「沒有什麼概念有絕對的重要性」，概念僅僅就是概念，它受到國家、文化、父母教育、學校教育、個人經驗等等影響，都僅僅是相對的。而既然是相對的，就表示是有機會透過思考、質疑、嘗試去做些調整，然後更接近自己想要的狀態、頻率。（雖然有些調整並不容易，畢竟我們都有習慣，又或者是來自外界的影響，但嘗試總會有機會）\n經過這樣的探索，我看到了新的可能性，也很好奇接下來的嘗試（歷程）會帶我到哪邊？會看到什麼樣的景色？\n","slug":"rediscover","date":"2023-10-26T16:00:00.000Z","categories_index":"生活","tags_index":"生活,隨筆","author_index":"Billy's blog"},{"id":"c055a8c0807ed4e545e8325e663a9e57","title":"JavaScript 傳值與傳參考","content":"JavaScript 的資料型別在討論到傳值(Call by Value)或傳參考(Call by Reference)之前，我們先來了解 JavaScript 的資料型別，它分為「原始型別」跟「物件型別」兩大分類。\n原始型別(純值)：\n\nBoolean\nString\nNumber\nNull\nUndefined\nBigInt\nSymbol\n\n物件型別：除了以上七種原始型別之外，其他都歸類為物件型別。（所以並沒有陣列型別、函式型別）\n傳值(Call by Value)、傳參考 (Call by Reference)了解到 JavaScript 的資料型別後，若以一般、基本狀況來說，原始型別的資料依循傳值的特性；而物件型別的資料則依循傳參考的特性。\n傳值(Call by Value)jsvar num1 = 10;\nvar num2 = 10;\nconsole.log(num1 === num2); // truejsvar num1 = 10;\nvar num2 = num1;\nnum2 = 100;\nconsole.log(num1 === num2); // false\nconsole.log(num1, num2); // 10, 100如上方兩個範例所示，如果你有一些些 JS 基礎，對於 console.log 的內容應該不會意外，我們以第二個範例作執行流程：\n\nvar num1 = 10;，宣告一個 num1 的變數，並指定為 10，這裡會建立一個記憶體(假設為0x01)來儲存 10 這個值。\nvar num2 = num1;，宣告一個 num2 的變數，並指定為 num1，這裡的 num2 會建立另一個記憶體(假設為0x02)，並將 num1 的值(10)複製過來儲存。\nnum2 = 100; 將 num2 的值改為 100。\nconsole.log(num1 === num2); console.log(num1, num2) num2 的更動並不會影響到 num1，因為他們存在於兩個不同的記憶體位置，num1 的值為 10，而 num2 的值為 100。\n\n在原始型別的變數赋值和傳遞是以”值”來進行的，值跟值的關係是獨立不連動的。\n傳參考 (Call by Reference)jsvar obj1 = &#123;\n  num: 10,\n&#125;\nvar obj2 = &#123;\n  num: 10,\n&#125;\nconsole.log(obj1 === obj2); // false物件在建立時，一樣會產生記憶體，不過這邊的變數儲存的是”記憶體位置”，而不是值（內容）。如上方範例所示，即使兩個物件內容是一致的，在console.log是得到不相等的，因為 obj1 跟 obj2 的記憶體參照位置不同。\njsvar obj1 = &#123;\n  num: 10,\n&#125;\nvar obj2 = obj1;\nobj2.num = 100;\nconsole.log(obj1.num, obj2.num); // 100, 100\nconsole.log(obj1 === obj2); // true我們再從這個範例拆解來更了解傳參考：\n\nvar obj1 = &#123; num: 10 &#125;，我們建立了一個內容為 &#123;num: 10&#125;的物件，而這個內容會儲存到記憶體(假設為 0x01)，而 obj1 這個變數是指向這個 0x01 的位置。\nvar obj2 = obj1;，接著我們將 obj1 給賦予到 obj2 變數，不過因為不是”創建”物件，所以 obj2 變數是指向到 0x01 的位置，也就是說 obj2 跟 obj1 都指向相同的記憶體位置。\nobj2.num = 100;，雖然以變數名稱來說，似乎是針對 obj2 裡頭的內容做調整，但其實是調整到 0x01 這個記憶體位置所對應的內容。\nconsole.log(obj1.num, obj2.num);，因為都是在 0x01 這個記憶體位置，所以兩者是相同且連動的。\n\n在物件型別中，變數的赋值和傳遞是以”記憶體位置”來做參照的。\n例外跟結論jsvar obj1 = &#123;\n  num: 10,\n&#125;\n\nfunction changeNum(param) &#123;\n  param.num = 100;\n&#125;\n\nchangeNum(obj1);\nconsole.log(obj1); // &#123;num: 100&#125;在上個段落的一開始提到，若以一般、基本狀況來說，原始型別的資料依循傳值的特性，而物件型別的資料則依循傳參考的特性。所以對於上方的範例結果，應該不會感到意外，即使作為 param 參數，它還是指向同個記憶體位置。\n而有了一般狀況，就會有例外，接著我們來看例外的狀況是什麼。\njs\nvar obj1 = &#123;\n  num: 10,\n&#125;\n\nfunction changeNum(param) &#123;\n  param = &#123; num: 1000 &#125;\n&#125;\n\nchangeNum(obj1);\nconsole.log(obj1); // 仍然是 num: 10\n如果依照剛才提到的傳參考，因為記憶體的指向，我們應該會推敲console.log(obj1);的結果是 &#123; num: 1000 &#125;；不過實際上得到的結果是 &#123;num: 10&#125;，也就是參數(param)中指向新物件時，記憶體將會重新指向，而與原先的物件(obj1)將沒有關聯性。所以主流上對於這個特性，比較大宗是以 Call by Sharing 這個名詞來做解釋，我自己在複習（補技術債）時也燒腦了一下；不過後來覺得不用太拘泥在這些名詞，而是知道 JS 的這些特性，盡可能避免踩雷。\n參考資料0 陷阱！0 誤解！8 天重新認識 JavaScript！\n看完這本就會懂！帶你無痛提升 JavaScript 面試力\n深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？\n[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念\nJS基本觀念：call by value 還是reference 又或是 sharing?\n","slug":"js-value-or-reference","date":"2023-10-26T02:51:17.000Z","categories_index":"前端","tags_index":"JavaScript,技術債","author_index":"Billy's blog"},{"id":"e517dd3c3a2180f60024bf64fe91a946","title":"六角學院 React 入門工作坊第四週（最終）","content":"Photo by Lautaro Andreani on Unsplash\n前言這週很有感的課程內容：React 的優點是體驗 JS 的美好，而缺點也是 JS 的美好；Vue 的優點是幫開發者做了很多，而缺點也是幫開發者做了很多。這段很符合我學習 Vue 跟 React 的心情寫照，2020 參加六角的 Vue 直播班時，剛開始覺得 Vue 的語法有點麻煩，要記滿多規矩的，雖然後來習慣就好了；而今年接觸 React 時，剛開始覺得好自由（真香），但隨著接觸時間稍長，就開始想起 Vue 的好 XD （框架都是工具，最重要的還是要達成什麼） \n因為已經有了第三週的打底，所以這週的作業時間就會比較短。這邊先拆解一下流程：\n\nReact Router：初步分好註冊、登入、Todo 頁面\n刻畫面：這個部分就不列在文章內容中。本來第三週還滿懶惰的，所以是拿課程範例來改；不過等到要做最終作業時，又有點手癢想手刻一下…\n註冊頁面\n除了原先的註冊 api，也會引入 SweetAlert2 做註冊成功或失敗的 popup 提示 (全部頁面都會使用)\n註冊成功後，導向到登入頁面\n防止註冊按鈕被連續點擊\n\n\n登入頁面\n登入成功與失敗，會用 popup 做提示。登入成功時，設置秒數導至 todo 頁面\n登入成功後取得 token，並儲存在 document.cookie\n防止登入按鈕被連續點擊\n\n\nTodo 頁面\nstate 定義\n驗證 api：驗證成功就可以使用 todo，如果驗證失敗，就用 popup 提醒使用者，並導回登入頁\n取得待辦資料 (getTodo)\n待辦的新增、刪除、編輯、狀態切換（成功與失敗的提醒）\n全部、待完成、已完成的待辦篩選\n從 todo 分出的元件 \n待完成待辦的數量顯示、清除已完成項目功能\n（2023.09.04 調整，原先寫錯成”已完成待辦的數量顯示”，程式以及這篇文章已調整為”待完成”）\n\n\n登出，popup 提醒使用者，然後導到登入頁\n\n\n\n第四週作品第四週程式碼\n\nReact Router首先在專案中，引入 React Router npm i react-router-dom，然後在 main.jsx 進入點，從 React Router 引用 &lt;HashRouter&gt; 並包在 &lt;App&gt; 的外層。\n接著可以照著課程指導的步驟：\n\n建立元件（頁面元件放在 view 資料夾）\n設置路由表 （import 元件）\n加入連結 （這邊不會用到）\n\njsx// main.jsx\nimport ReactDOM from &quot;react-dom/client&quot;;\nimport &#123; HashRouter &#125; from &quot;react-router-dom&quot;;\nimport App from &quot;./App.jsx&quot;;\n\nReactDOM.createRoot(document.getElementById(&quot;root&quot;)).render(\n  &lt;HashRouter&gt;\n    &lt;App /&gt;\n  &lt;/HashRouter&gt;\n);jsx// App.jsx\nimport &#123; Routes, Route &#125; from &quot;react-router-dom&quot;;\nimport &quot;./styles/all.sass&quot;;\nimport SignUp from &quot;./views/SignUp.jsx&quot;;\nimport SignIn from &quot;./views/SignIn.jsx&quot;;\nimport Todo from &quot;./views/Todo.jsx&quot;;\n\nfunction App() &#123;\n  return (\n    &lt;&gt;\n      &lt;Routes&gt;\n        &lt;Route path=&quot;/&quot; element=&#123;&lt;SignIn /&gt;&#125; /&gt;\n        &lt;Route path=&quot;/signup&quot; element=&#123;&lt;SignUp /&gt;&#125; /&gt;\n        &lt;Route path=&quot;/todo&quot; element=&#123;&lt;Todo /&gt;&#125; /&gt;\n      &lt;/Routes&gt;\n    &lt;/&gt;\n  );\n&#125;\nexport default App;\nAPI跟第三週一樣把 api 獨立成一支 js 來管理，不過內容有一些不同，因為在 todo 頁面驗證後，會在 todoBase 這個 axios 實體帶入以下這個設定：todoBase.defaults.headers.common[&quot;Authorization&quot;] = todoToken，所以在 todo 頁面用到的 api 就可以省略 headers 這個參數\njs// api/index.js\nimport axios from &quot;axios&quot;;\n\n// todolist api\nexport const todoBase = axios.create(&#123;\n  baseURL: &quot;https://todolist-api.hexschool.io&quot;,\n&#125;);\n\n// 註冊\nexport const apiUsersSignUp = (data) =&gt; todoBase.post(&quot;/users/sign_up&quot;, data);\n\n// 登入\nexport const apiUsersSignIn = (data) =&gt; todoBase.post(&quot;/users/sign_in&quot;, data);\n\n// 驗證\nexport const apiUsersCheckout = (headers) =&gt; todoBase.get(&quot;/users/checkout&quot;, headers);\n\n// 登出\nexport const apiUsersSignOut = () =&gt; todoBase.post(&quot;/users/sign_out&quot;, &#123;&#125;);\n\n// 取得所有待辦\nexport const apiGetTodos = () =&gt; todoBase.get(&quot;/todos/&quot;);\n\n// 新增待辦\nexport const apiPostTodos = (data) =&gt; todoBase.post(&quot;/todos/&quot;, data);\n\n// 刪除待辦\nexport const apiDeleteTodos = (id) =&gt; todoBase.delete(`/todos/$&#123;id&#125;`);\n\n// 切換待辦狀態\nexport const apiPatchTodos = (id) =&gt; todoBase.patch(`/todos/$&#123;id&#125;/toggle`, &#123;&#125;);\n\n// 編輯待辦文字\nexport const apiPutTodos = (id, data) =&gt; todoBase.put(`/todos/$&#123;id&#125;`, data);\n註冊這邊單純呈現註冊頁的畫面部分：\njsx// signUp.jsx\n// ... 略\n\nreturn (\n  &lt;div id=&quot;sign-up&quot; className=&quot;content&quot;&gt;\n    &lt;div className=&quot;content__header&quot;&gt;\n      &lt;h2 className=&quot;content__title&quot;&gt;註冊帳號&lt;/h2&gt;\n    &lt;/div&gt;\n    &lt;div className=&quot;content__body&quot;&gt;\n      &lt;form className=&quot;form&quot; onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt;\n        &lt;div className=&quot;form__item&quot;&gt;\n          &lt;label className=&quot;form__label&quot; htmlFor=&quot;signupEmail&quot;&gt;\n            Email\n          &lt;/label&gt;\n          &lt;input\n            className=&quot;form__input&quot;\n            type=&quot;email&quot;\n            id=&quot;signupEmail&quot;\n            placeholder=&quot;請輸入 email&quot;\n            required\n            &#123;...register(&quot;email&quot;)&#125;\n          /&gt;\n        &lt;/div&gt;\n        &lt;div className=&quot;form__item&quot;&gt;\n          &lt;label className=&quot;form__label&quot; htmlFor=&quot;nickname&quot;&gt;\n            您的暱稱\n          &lt;/label&gt;\n          &lt;input\n            className=&quot;form__input&quot;\n            type=&quot;text&quot;\n            id=&quot;nickname&quot;\n            placeholder=&quot;請輸入您的暱稱&quot;\n            required\n            &#123;...register(&quot;nickname&quot;)&#125;\n          /&gt;\n        &lt;/div&gt;\n\n        &lt;div className=&quot;form__item&quot;&gt;\n          &lt;label className=&quot;form__label&quot; htmlFor=&quot;signupPassword&quot;&gt;\n            密碼\n          &lt;/label&gt;\n          &lt;input\n            className=&quot;form__input&quot;\n            type=&quot;password&quot;\n            id=&quot;signupPassword&quot;\n            placeholder=&quot;請輸入密碼&quot;\n            required\n            &#123;...register(&quot;password&quot;)&#125;\n          /&gt;\n        &lt;/div&gt;\n        &lt;div className=&quot;text-center mt-6&quot;&gt;\n          &lt;button className=&quot;form__button&quot; type=&quot;submit&quot;&gt;\n            註冊帳號\n          &lt;/button&gt;\n        &lt;/div&gt;\n        &lt;div className=&quot;text-center mt-3&quot;&gt;\n          已有帳號了？&lt;NavLink to=&quot;/&quot;&gt;登入&lt;/NavLink&gt;\n        &lt;/div&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n);\n再來是註冊的程式部分：\n\n當填好表單按下註冊按鈕時，會執行 onSubmit 這個函式，並在參數中帶進表單資料，接著就會運行註冊的 api \n註冊成功或失敗時，會使用 sweetalert2 引入的 popup 來通知使用者\n註冊成功或失敗時，會將表單欄位清空。這邊是從 useForm 引出 reset 的功能\n註冊成功時，會透過 navigate 導到登入頁面\nconst [isDisabled, setDisabled] = useState(false); 這個狀態的定義，主要是綁在註冊按鈕的 disabled，在 api 過程讓按鈕為不能點擊的狀態，直到 api 過程結束（防止按鈕被連續點擊）\n\njsx// signUp.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useState &#125; from &quot;react&quot;;\nimport &#123; NavLink, useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useForm &#125; from &quot;react-hook-form&quot;;\nimport &#123; apiUsersSignUp &#125; from &quot;../api&quot;;\n\nconst SignUp = () =&gt; &#123;\n  const [isDisabled, setDisabled] = useState(false);\n  const &#123; register, handleSubmit, reset &#125; = useForm();\n\n  const resetHandle = () =&gt; &#123;\n    reset();\n  &#125;;\n\n  const navigate = useNavigate();\n\n  const onSubmit = (data) =&gt; &#123;\n    setDisabled(true);\n    apiUsersSignUp(data)\n      .then(() =&gt; &#123;\n        Swal.fire(&#123;\n          title: &quot;恭喜註冊成功！&quot;,\n          text: &quot;為您導至登入頁...&quot;,\n          icon: &quot;success&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n        setTimeout(() =&gt; &#123;\n          navigate(&quot;/&quot;);\n        &#125;, 1500);\n      &#125;)\n      .catch((error) =&gt; &#123;\n        Swal.fire(&#123;\n          title: error.response.data.message,\n          icon: &quot;error&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n      &#125;)\n      .finally(() =&gt; &#123;\n        setDisabled(false);\n        resetHandle();\n      &#125;);\n  &#125;;\n  return(\n    // ... 略\n  )\n&#125;登入跟註冊頁面相似，所以這邊只呈現程式部分：\n\n登入成功或失敗時，會使用 sweetalert2 引入的 popup 來通知使用者\n登入成功或失敗時，會將表單欄位清空。這邊是從 useForm 引出 reset 的功能\n登入成功後，會從回應資料取出 token，並存到 document.cookie，待之後 todo 頁面再取出\n登入成功後，使用 navigate 導向到 todo 頁面\nconst [isDisabled, setDisabled] = useState(false); 這個狀態的定義，主要是綁在登入按鈕的 disabled，在 api 過程讓按鈕為不能點擊的狀態，直到 api 過程結束（防止按鈕被連續點擊）\n\njsx// signIn.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useState &#125; from &quot;react&quot;;\nimport &#123; NavLink, useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useForm &#125; from &quot;react-hook-form&quot;;\nimport &#123; apiUsersSignIn &#125; from &quot;../api&quot;;\n\nconst SignIn = () =&gt; &#123;\n  const [isDisabled, setDisabled] = useState(false);\n  const &#123; register, handleSubmit, reset &#125; = useForm();\n\n  const resetHandle = () =&gt; &#123;\n    reset();\n  &#125;;\n\n  const navigate = useNavigate();\n\n  const onSubmit = (data) =&gt; &#123;\n    setDisabled(true);\n    apiUsersSignIn(data)\n      .then((res) =&gt; &#123;\n        const &#123; token &#125; = res.data;\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        document.cookie = `token=$&#123;token&#125;;expires=$&#123;tomorrow.toUTCString()&#125;`;\n        Swal.fire(&#123;\n          title: &quot;登入成功！&quot;,\n          text: &quot;為您導至 Todo 頁面...&quot;,\n          icon: &quot;success&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n        setTimeout(() =&gt; &#123;\n          navigate(&quot;/todo&quot;);\n        &#125;, 1500);\n      &#125;)\n      .catch(() =&gt; &#123;\n        Swal.fire(&#123;\n          title: &quot;登入失敗&quot;,\n          text: &quot;請檢查帳密是否正確，或是否有註冊過。&quot;,\n          icon: &quot;error&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n      &#125;)\n      .finally(() =&gt; &#123;\n        setDisabled(false);\n        resetHandle();\n      &#125;);\n  &#125;;\n&#125;Todo 頁state 定義首先我們先定義好會用到的 state：\n\ntodo 資料：const [todo, setTodo] = useState([])  \ntodo 資料的分類（全部、待完成、已完成）：const [todoType, setTodoType] = useState(&quot;all&quot;); \n待辦事項 input：const [input, setInput] = useState(&quot;&quot;) \n用戶的 nickname：const [nickname, setNickname] = useState(&quot;&quot;) \n編輯的時候會使用上暫存物件：const [editTarget, setEditTarget] = useState(&#123;&#125;)\n\n驗證 api進到 todo 頁面時，首先需先經過 token 的驗證，驗證成功才能在此頁面操作，否則就會通知驗證失敗並導回登入頁。\n\n從 document.cookie 取出剛才在登入成功時設置的 token，並存取在 todoToken 這個變數中\n設置 checkLogin 這個函式，內容會使用 apiUsersCheckout 這支驗證 api，記得要帶上 headers:&#123;Authorization: todoToken&#125;\n驗證成功時會設置 nickname， 以及將 token 設置在 todoBase 這個實體，之後在 todo 頁面的 api 操作都不需帶上 headers:&#123;Authorization: todoToken&#125;，接著透過 getTodos() 獲取所有待辦項目。（這個步驟還未定義 getTodos()）\n驗證失敗時，會用 popup 來通知，之後導回登入頁面\n\n\n透過 useEffect 去執行 checkLogin 這個函式（第二個空陣列參數，表示只有最開始時會執行一次）\n\njsx// todo.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123;\n  apiUsersCheckout,\n  apiGetTodos,\n  apiPostTodos,\n  apiDeleteTodos,\n  apiPatchTodos,\n  apiPutTodos,\n  todoBase,\n  apiUsersSignOut,\n&#125; from &quot;../api&quot;;\n\nconst Todo = () =&gt; &#123;\n  // ... 略\n  const navigate = useNavigate();\n\n  const todoToken = document.cookie\n    .split(&quot;; &quot;)\n    .find((row) =&gt; row.startsWith(&quot;token=&quot;))\n    ?.split(&quot;=&quot;)[1];\n\n  const checkLogin = () =&gt; &#123;\n    apiUsersCheckout(&#123;\n      headers: &#123;\n        Authorization: todoToken,\n      &#125;,\n    &#125;)\n      .then((res) =&gt; &#123;\n        setNickname(res.data.nickname);\n        todoBase.defaults.headers.common[&quot;Authorization&quot;] = todoToken;\n        getTodos();\n      &#125;)\n      .catch(() =&gt; &#123;\n        Swal.fire(&#123;\n          title: &quot;驗證失敗，請先登入&quot;,\n          text: &quot;稍後導至登入頁&quot;,\n          icon: &quot;error&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n        setTimeout(() =&gt; &#123;\n          navigate(&quot;/&quot;);\n        &#125;, 1500);\n      &#125;);\n  &#125;;\n\n  useEffect(() =&gt; &#123;\n    checkLogin();\n  &#125;, []);\n  // ... 略\n&#125;\n取得待辦資料 (getTodos)再來我們要定義 getTodos 這個函式，內容透過 apiGetTodos() 這支取得所有待辦的 api 來取得資料。不論在驗證後，以及新增、刪除、修改待辦等動作都會來執行這個函式，重新抓取最新資料。\njsx// todo.jsx\n// ... 略\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123;\n  apiUsersCheckout,\n  apiGetTodos,\n  apiPostTodos,\n  apiDeleteTodos,\n  apiPatchTodos,\n  apiPutTodos,\n  todoBase,\n  apiUsersSignOut,\n&#125; from &quot;../api&quot;;\n\nconst Todo = () =&gt; &#123;\n  const [todo, setTodo] = useState([]);\n  // ... 略\n  const getTodos = () =&gt; &#123;\n    apiGetTodos()\n      .then((res) =&gt; &#123;\n        setTodo(res.data.data);\n      &#125;)\n      .catch((err) =&gt; &#123;\n        console.log(err);\n      &#125;);\n  &#125;;\n  // ... 略\n&#125;\n待辦的新增、刪除、編輯、狀態切換在待辦的新增、刪除、編輯、狀態切換等函式中，除了從 api&#x2F;index.js 取得各個 api 操作，也使用上 SweetAlert2 的 Toast 設置，在 api 執行後的成功或失敗做個通知。\n提醒：\n\n在每個 api 執行後，記得呼叫 getTodos()，重新獲得最新資料\n待辦新增（addTodo）記得要清空 input（setInput(&quot;&quot;)）\n刪除與編輯記得要帶上 id \n編輯待辦（updateTodo），記得要清空暫存的物件（setEditTarget(&#123;&#125;)）\n\njsx// todo.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123;\n  apiUsersCheckout,\n  apiGetTodos,\n  apiPostTodos,\n  apiDeleteTodos,\n  apiPatchTodos,\n  apiPutTodos,\n  todoBase,\n  apiUsersSignOut,\n&#125; from &quot;../api&quot;;\nconst Todo = () =&gt; &#123;\n  const [todo, setTodo] = useState([]);\n  const [todoType, setTodoType] = useState(&quot;all&quot;);\n  const [input, setInput] = useState(&quot;&quot;);\n  const [nickname, setNickname] = useState(&quot;&quot;);\n  const [editTarget, setEditTarget] = useState(&#123;&#125;);\n\n  // ...略\n  const Toast = Swal.mixin(&#123;\n    toast: true,\n    position: &quot;top-end&quot;,\n    showConfirmButton: false,\n    customClass: &#123;\n      popup: &quot;colored-toast&quot;,\n    &#125;,\n    timer: 1500,\n    timerProgressBar: true,\n  &#125;);\n\n  // 新增項目\n  const addTodo = () =&gt; &#123;\n    if (input === &quot;&quot;) return;\n    apiPostTodos(&#123; content: input &#125;)\n      .then(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;success&quot;,\n          title: &quot;新增待辦成功&quot;,\n        &#125;);\n        getTodos();\n      &#125;)\n      .catch(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;error&quot;,\n          title: &quot;新增待辦失敗，請再檢查看看&quot;,\n        &#125;);\n      &#125;).finally(() =&gt; &#123;\n        setInput(&quot;&quot;); // 清空\n        setTodoType(&quot;all&quot;); // 將頁籤切換為「全部」\n      &#125;);\n  &#125;;\n\n  // 刪除項目\n  const deleteTodo = (id) =&gt; &#123;\n    apiDeleteTodos(id)\n      .then(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;success&quot;,\n          title: &quot;刪除待辦成功&quot;,\n        &#125;);\n        getTodos();\n      &#125;)\n      .catch(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;error&quot;,\n          title: &quot;刪除待辦失敗，請再檢查看看&quot;,\n        &#125;);\n      &#125;);\n  &#125;;\n\n  // 切換狀態（是否完成）\n  const toggleTodo = (id) =&gt; &#123;\n    apiPatchTodos(id)\n      .then(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;success&quot;,\n          title: &quot;待辦狀態更新成功&quot;,\n        &#125;);\n        getTodos();\n      &#125;)\n      .catch(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;error&quot;,\n          title: &quot;待辦狀態更新失敗，請再檢查看看&quot;,\n        &#125;);\n      &#125;);\n  &#125;;\n\n  // 編輯項目\n  const updateTodo = (id, content) =&gt; &#123;\n    apiPutTodos(id, &#123; content &#125;)\n      .then(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;success&quot;,\n          title: &quot;編輯待辦成功&quot;,\n        &#125;);\n        getTodos();\n      &#125;)\n      .catch(() =&gt; &#123;\n        Toast.fire(&#123;\n          icon: &quot;error&quot;,\n          title: &quot;編輯待辦失敗，請再檢查看看&quot;,\n        &#125;);\n      &#125;).finally(() =&gt; &#123;\n        setEditTarget(&#123;&#125;);\n      &#125;);\n  &#125;;\n\n  //...略\n&#125;全部、待完成、已完成的待辦篩選\n如同我們前面定義的 const [todoType, setTodoType] = useState(&quot;all&quot;);，這個部分用來定義 todo 篩選的三種狀態：全部（all）、待完成（active）、已完成（completed）\n再來我們用 todoTypeChange 這個函式來定義 todoType 狀態的切換，這是使用按鈕點擊（帶上狀態）來觸發\n根據 todoType 狀態的不同，用 todo.filter 來篩選出我們需要的資料，並存在 filterTodo 這個變數中，之後在樣板中是以 filterTodo.map() 來渲染\n根據 todoType 狀態的不同，做 active class 的切換\n\njsxconst Todo = () =&gt; &#123;\n  const [todo, setTodo] = useState([]);\n  const [todoType, setTodoType] = useState(&quot;all&quot;);\n  // ... 略\n\n  // 切換：全部、待完成、已完成\n  const todoTypeChange = (status) =&gt; &#123;\n    setTodoType(status);\n  &#125;;\n\n  // 根據 todoType ，決定顯示要什麼資料\n  const filterTodo = todo.filter((item) =&gt; &#123;\n    if (todoType === &quot;completed&quot;) &#123;\n      return item.status;\n    &#125;\n    if (todoType === &quot;active&quot;) &#123;\n      return !item.status;\n    &#125;\n    return true;\n  &#125;);\n\n  return (\n    // ... 略\n    &lt;div className=&quot;todo__category&quot;&gt;\n      &lt;button\n        className=&#123;`todo__category__list $&#123;\n          todoType === &quot;all&quot; ? &quot;active&quot; : &quot;&quot;\n        &#125;`&#125;\n        onClick=&#123;() =&gt; todoTypeChange(&quot;all&quot;)&#125;\n      &gt;\n        全部\n      &lt;/button&gt;\n      &lt;button\n        className=&#123;`todo__category__list $&#123;\n          todoType === &quot;active&quot; ? &quot;active&quot; : &quot;&quot;\n        &#125;`&#125;\n        onClick=&#123;() =&gt; todoTypeChange(&quot;active&quot;)&#125;\n      &gt;\n        待完成\n      &lt;/button&gt;\n      &lt;button\n        className=&#123;`todo__category__list $&#123;\n          todoType === &quot;completed&quot; ? &quot;active&quot; : &quot;&quot;\n        &#125;`&#125;\n        onClick=&#123;() =&gt; todoTypeChange(&quot;completed&quot;)&#125;\n      &gt;\n        已完成\n      &lt;/button&gt;\n    &lt;/div&gt;\n    &lt;ul className=&quot;todo__list&quot;&gt;\n      &#123;filterTodo.map((item) =&gt; &#123;\n        return (\n          &lt;TodoItem\n            // ...略\n          /&gt;\n        );\n      &#125;)&#125;\n    &lt;/ul&gt;\n    // ... 略\n  )\n&#125;從 todo 分出的元件這次有從 todo 頁面中，分出 TodoItem（todo 項目）、TodoCategory（todo 篩選）這兩個元件。而這個段落會來提一下 TodoItem 這個元件，根據這個元件所需，我們得傳入 todo 項目的資訊（id、content、status），以及一些待辦的函式（刪除、狀態切換、編輯…等），可看下方程式碼的註解。\njsx// todo.jsx\n// ... 略\nimport TodoItem from &quot;../components/TodoItem&quot;;\nimport TodoCategory from &quot;../components/TodoCategory&quot;;\n\nconst Todo = () =&gt; &#123;\n  const [todo, setTodo] = useState([]);\n  const [todoType, setTodoType] = useState(&quot;all&quot;);\n  const [input, setInput] = useState(&quot;&quot;);\n  const [nickname, setNickname] = useState(&quot;&quot;);\n  const [editTarget, setEditTarget] = useState(&#123;&#125;);\n\n  // ... 略\n\n  // 刪除項目\n  const deleteTodo = (id) =&gt; &#123;\n    // ... 略\n  &#125;;\n\n  // 切換狀態（是否完成）\n  const toggleTodo = (id) =&gt; &#123;\n    // ... 略\n  &#125;;\n\n  // 編輯項目\n  const updateTodo = (id, content) =&gt; &#123;\n    // ... 略\n  &#125;;\n\n  // 切換：全部、待完成、已完成\n  const todoTypeChange = (status) =&gt; &#123;\n    setTodoType(status);\n  &#125;;\n\n  // 根據 todoType ，決定顯示要什麼資料\n  const filterTodo = todo.filter((item) =&gt; &#123;\n    if (todoType === &quot;completed&quot;) &#123;\n      return item.status;\n    &#125;\n    if (todoType === &quot;active&quot;) &#123;\n      return !item.status;\n    &#125;\n    return true;\n  &#125;);\n\n\n  return (\n    // ... 略\n    &lt;div className=&quot;todo__content&quot;&gt;\n      &lt;TodoCategory\n        todoType=&#123;todoType&#125;\n        todoTypeChange=&#123;todoTypeChange&#125;\n      /&gt;\n\n      &lt;ul className=&quot;todo__list&quot;&gt;\n        &#123;filterTodo.map((item) =&gt; &#123;\n          return (\n            &lt;TodoItem\n              key=&#123;item.id&#125; // id\n              id=&#123;item.id&#125; // id\n              content=&#123;item.content&#125; // input text\n              status=&#123;item.status&#125; // 狀態，預設為待完成\n              toggleTodo=&#123;toggleTodo&#125; // 狀態切換的函式\n              deleteTodo=&#123;deleteTodo&#125; // 刪除項目的函式\n              editTarget=&#123;editTarget&#125; // 當前編輯的暫存物件 （存 id、content)\n              setEditTarget=&#123;setEditTarget&#125; // 當前編輯的暫存物件\n              updateTodo=&#123;updateTodo&#125; // 編輯項目的函式\n            /&gt;\n          );\n        &#125;)&#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\nexport default Todo;\n接下來是 TodoItem.jsx 這個元件本身，要使用透過父層（props）傳進來的資料或函式時，需先引用 propTypes 來做定義。\n再來會提到 editTarget 跟 setEditTarget 的部分，在定義上是用來存取暫時資料，方便用於程式上的判斷。當我們初始去點擊編輯 icon 時，就會觸發 setEditTarget(&#123; id, content &#125;)，並將項目的 id 跟 content(input) 給傳入做暫時資料。而這樣的暫時資料，可以在畫面使用 editTarget.id === id 這樣的方式，來判斷我們點到的是哪一個項目，並顯示相對應的內容。例如我們點到第二個項目，對於這個項目就會顯示一個 input 框，以及一個 check icon，而當我們點擊 check icon 時，就會觸發 updateTodo 的功能，並將 id 跟新的 content(input) 帶進去執行編輯的 api。\njsx// TodoItem.jsx\nimport propTypes from &quot;prop-types&quot;;\n\nconst TodoItem = (&#123;\n  id,\n  content,\n  status,\n  toggleTodo,\n  deleteTodo,\n  editTarget,\n  setEditTarget,\n  updateTodo,\n&#125;) =&gt; &#123;\n  const atChange = () =&gt; &#123;\n    toggleTodo(id);\n  &#125;;\n  const atClickDelete = () =&gt; &#123;\n    deleteTodo(id);\n  &#125;;\n  const atClickEdit = (id, content) =&gt; &#123;\n    updateTodo(id, content);\n  &#125;;\n\n  return (\n    &lt;li className=&quot;todo__item&quot;&gt;\n      &lt;label className=&quot;todo__label&quot; htmlFor=&#123;id&#125;&gt;\n        &lt;input\n          className=&quot;todo__check&quot;\n          type=&quot;checkbox&quot;\n          id=&#123;id&#125;\n          checked=&#123;status&#125;\n          onChange=&#123;atChange&#125;\n        /&gt;\n        &#123;editTarget.id === id ? (\n          &lt;input\n            className=&quot;form__input&quot;\n            type=&quot;text&quot;\n            value=&#123;editTarget.content&#125;\n            onChange=&#123;(e) =&gt; &#123;\n              setEditTarget(&#123; ...editTarget, content: e.target.value &#125;);\n            &#125;&#125;\n          /&gt;\n        ) : (\n          &lt;span className=&quot;todo__text&quot;&gt;&#123;content&#125;&lt;/span&gt;\n        )&#125;\n      &lt;/label&gt;\n      &lt;button type=&quot;button&quot; className=&quot;todo__icon&quot;&gt;\n        &#123;editTarget.id === id ? (\n          &lt;i\n            className=&quot;fa-solid fa-check&quot;\n            onClick=&#123;() =&gt; atClickEdit(editTarget.id, editTarget.content)&#125;\n          &gt;&lt;/i&gt;\n        ) : (\n          &lt;i\n            className=&quot;fa-regular fa-pen-to-square&quot;\n            onClick=&#123;() =&gt; &#123;\n              setEditTarget(&#123; id, content &#125;);\n            &#125;&#125;\n          &gt;&lt;/i&gt;\n        )&#125;\n      &lt;/button&gt;\n      &lt;button type=&quot;button&quot; className=&quot;todo__icon&quot; onClick=&#123;atClickDelete&#125;&gt;\n        &lt;i className=&quot;fa fa-times&quot; /&gt;\n      &lt;/button&gt;\n    &lt;/li&gt;\n  );\n&#125;;\n\nTodoItem.propTypes = &#123;\n  id: propTypes.string.isRequired,\n  content: propTypes.string.isRequired,\n  status: propTypes.bool.isRequired,\n  toggleTodo: propTypes.func.isRequired,\n  deleteTodo: propTypes.func.isRequired,\n  editTarget: propTypes.object.isRequired,\n  setEditTarget: propTypes.func.isRequired,\n  updateTodo: propTypes.func.isRequired,\n&#125;;\n\nexport default TodoItem;\n“待完成”待辦的數量顯示、清除”已完成”項目功能“待完成”待辦的數量顯示比較單純，宣告 todoUnCompleted 這個變數去儲存 todo 篩選待完成的項目，然後再用 &#123;todoUnCompleted.length&#125; 渲染到畫面上。\n而清除”已完成”項目的功能，則是使用 todo 去篩選已完成項目，然後帶入這些已完成項目的 id 到 apiDeleteTodos 做刪除處理。因為要刪除的項目不只一個，所以會使用到 Promise.all 來等待全部已完成的項目都被刪除後，再用 Toast 通知使用者。（記得 getTodos() 重新獲取資料。）\njsx// todo.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123;\n  apiUsersCheckout,\n  apiGetTodos,\n  apiPostTodos,\n  apiDeleteTodos,\n  apiPatchTodos,\n  apiPutTodos,\n  todoBase,\n  apiUsersSignOut,\n&#125; from &quot;../api&quot;;\n// ... 略\n\nconst Todo = () =&gt; &#123;\n  const [todo, setTodo] = useState([]);\n  const [todoType, setTodoType] = useState(&quot;all&quot;);\n  const [input, setInput] = useState(&quot;&quot;);\n  const [nickname, setNickname] = useState(&quot;&quot;);\n  const [editTarget, setEditTarget] = useState(&#123;&#125;);\n\n  // ... 略\n\n  // 從原先 list 資料去 filter\n    const todoUnCompleted = todo.filter((item) =&gt; &#123;\n        return !item.status;\n    &#125;);\n\n  // 清除已完成項目\n  const clearTodoCompleted = () =&gt; &#123;\n    const result = todo.filter((item) =&gt; &#123;\n      if (item.status) &#123;\n        apiDeleteTodos(item.id);\n      &#125;\n    &#125;);\n    Promise.all(result).then(() =&gt; &#123;\n      Toast.fire(&#123;\n        icon: &quot;success&quot;,\n        title: &quot;清除已完成項目成功&quot;,\n      &#125;);\n      getTodos();\n    &#125;);\n  &#125;;\n\n  return (\n    // ... 略\n    &lt;div className=&quot;todo__bottom&quot;&gt;\n      &lt;p className=&quot;todo__bottom__text&quot;&gt;\n        &#123;todoUnCompleted.length&#125; 個已完成項目\n      &lt;/p&gt;\n      &lt;button\n        className=&quot;todo__bottom__btn&quot;\n        onClick=&#123;clearTodoCompleted&#125;\n      &gt;\n        清除已完成項目\n      &lt;/button&gt;\n    &lt;/div&gt;\n  )\n&#125;登出登出在執行 apiUsersSignOut() 時，記得清理 document.cookie (document.cookie = &quot;token=; expires=;&quot;)\n在登出成功時，會透過 navigate 導回登入頁面\njsx// todo.jsx\nimport Swal from &quot;sweetalert2&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123;\n  apiUsersCheckout,\n  apiGetTodos,\n  apiPostTodos,\n  apiDeleteTodos,\n  apiPatchTodos,\n  apiPutTodos,\n  todoBase,\n  apiUsersSignOut,\n&#125; from &quot;../api&quot;;\n// ... 略\n\nconst Todo = () =&gt; &#123;\n  // ... 略\n\n  const navigate = useNavigate();\n\n  // ... 略\n\n  // 登出\n  const signOut = () =&gt; &#123;\n    apiUsersSignOut()\n      .then(() =&gt; &#123;\n        document.cookie = &quot;token=; expires=;&quot;;\n        Swal.fire(&#123;\n          title: &quot;您已登出&quot;,\n          text: &quot;為您導回登入頁面...&quot;,\n          icon: &quot;success&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n        setTimeout(() =&gt; &#123;\n          navigate(&quot;/&quot;);\n        &#125;, 1500);\n      &#125;)\n      .catch(() =&gt; &#123;\n        Swal.fire(&#123;\n          title: &quot;登出失敗，請再檢查看看&quot;,\n          icon: &quot;error&quot;,\n          showConfirmButton: false,\n          timer: 1500,\n        &#125;);\n      &#125;);\n  &#125;;\n\n  return(\n    // ... 略\n    &lt;div className=&quot;greet&quot;&gt;\n      &lt;h4 className=&quot;greet__text&quot;&gt;Hi~ &#123;nickname&#125;&lt;/h4&gt;\n      &lt;button className=&quot;greet__btn&quot; type=&quot;button&quot; onClick=&#123;signOut&#125;&gt;\n        登出\n      &lt;/button&gt;\n    &lt;/div&gt;\n    // ... 略\n  )\n&#125;\n\n結尾透過這幾週跟著作業產出拆解文章，比較有感的部分是狀況的掌握，不論正在製作哪個功能，或者正卡關在什麼地方，都比較不會混亂跟一片空白。\n講到一片空白，也來分享自己先前看書所學習到的。基本上來說，即使現在的科技相當發達，我們大腦主要還是以求生作為導向，所以當我們面臨太多資訊、思考太多時，大腦會容易處於當機狀態（避免過度耗能）。回想一下學生時期在準備考試時，是不是會突然開始整理房間呢？因為大腦判斷準備考試實在太麻煩（太耗能）了。而依循大腦這樣的特性，再來延伸說到寫文章跟拆解任務。\n關於寫文章這件事，過去我自己也都無法維持住，所以往往寫個一陣子就會放掉；後來在一些探索下，我知道了無法維持的原因，因為會很貪心的在寫文章這件事添加很多資訊（完美主義作祟），像是要寫到什麼程度、別人怎麼看、是否容易理解…等等，可是這樣太多的想法、期待、資訊只會讓大腦很快的當機，初步就無法維持習慣，畢竟阻力實在太大了。\n所以我們可以先降低門檻，以自己為出發點：對於什麼議題有興趣、什麼部分之後會用到、想要練習什麼，或者單純分享自己踩到的雷。放掉只是想像的期待，寫的好與壞其實都沒關係，畢竟還在起頭建立習慣。像是我 8 月中做的這個 Pinia 筆記，雖然簡簡單單，但沒多久我在寫 Nuxt 專案時就派上用場了。如果嘗試後真的寫不下去也沒關係，也許你是透過大量練習、實戰在組織自己知識的人；也可能是在多些經驗後，發現寫筆記、Blog 對自己的重要性，It’s all ok。\n再來討論到拆解任務，這也是我操作後相當推薦的方法。剛開始成為前端時，每當新專案一來（或者舊專案要修改），二話不說就是直接打開編輯器開工；不過當工作累積一些經驗後，變成專案一來會先規劃跟拆解，基本上我電腦桌的附近一定會擺上筆記本或紙。而這樣的拆解在專案的進行上會比較順，也是順著大腦的特性走，讓它不會一次進太多資訊而當機。不過在實際專案上，因為有時間上的壓力，無法像上課這樣拆解的比較細，所以可以好好利用上課來嘗試拆解。\n感謝你看到這邊，一不注意就在結尾處提了比較多。若有什麼部分寫錯，也再麻煩跟我說，感恩！\n（感謝 Evan 同學發現待辦 CRUD 沒寫好的部分！）（感謝助教提供優化部分！）\n","slug":"react-workshop-week4","date":"2023-08-30T16:00:00.000Z","categories_index":"前端","tags_index":"六角學院,React","author_index":"Billy's blog"},{"id":"a00a13968a12e61d4218783175346631","title":"六角學院 React 入門工作坊第三週","content":"Photo by Lautaro Andreani on Unsplash\n前言第三週因為事情比較多，所以整體的進度慢了一些。上課也只能跟到前半段 30 分鐘，覺得曠掉直播課是滿可惜的(QQ)，而且也可能會錯過尿點知識；後來在隔天老師上傳錄影檔時，就趕快補上進度，這週的主軸核心為 API 串接，可以好好做個練習，上課時老師也會補上一些知識點（ex: JWT），並講解的比較好理解。\n這週因為一些規劃跟時間關係，所以會跟前兩週完整拆解的方式不同，這邊抽出三個部分來分享：\n\nReact Hook Form\nAxios 的 API 管理\n關於 API 串接練習\n\n第三週作品\n\nReact Hook Form一開始在寫註冊這個元件時，忽然興起了找表單套件的想法，後來就找到了React Hook Form，也決定在這次作業中來嘗試一下。 \n起手安裝txtnpm install react-hook-form引用\n在元件中透過 import &#123; useForm &#125; from &quot;react-hook-form&quot;，從表單套件引用 useForm 這個功能\n接著從 useForm 的執行中，解構出 register 跟 handleSubmit。（前者處理資料，後者處理表單提交相關）\n再來定義好表單送出的 onSubmit 函式，這是屬於自定義的函式，所以命名也是自定義的。稍後就會提到這個自定義函式的 data 參數。\n\njsximport &#123; useForm &#125; from &quot;react-hook-form&quot;; \n\nconst SignUp = () =&gt; &#123;\n  const &#123;\n    register, // state\n    handleSubmit, // submit\n  &#125; = useForm(); \n\n  const onSubmit = (data) =&gt; &#123;\n    // 自定義的 submit\n    console.log(data);\n  &#125;;\n\n  return (&lt;&gt;...略&lt;/&gt;)\n&#125;在 jsx 中使用接著我們來看 jsx 樣板部分：\n\n如稍早所述 register 是處理資料相關，它用來建立表單元素跟資料的關聯。在下方程式碼的三個 input 中，我們都能看到 &#123;...register(&quot;欄位命名&quot;)&#125; 這樣的方式，將 state 登記（綁定）到某個表單元素。\n而在 form tag 的部分，handleSubmit 是處理表單提交的函式，透過這樣 &#123;handleSubmit(onSubmit)&#125; 把我們自定義的函式丟進去，就能在表單送出後，在自定義函式的參數中，得到 register 的資料。\n\n（爲了方便理解，所以有稍微省略一些程式碼結構）\njsxreturn (\n  &lt;div id=&quot;signUpPage&quot; className=&quot;bg-yellow&quot;&gt;\n    &lt;form\n      className=&quot;formControls&quot;\n      action=&quot;&quot;\n      onSubmit=&#123;handleSubmit(onSubmit)&#125;\n    &gt;\n      &lt;h2 className=&quot;formControls_txt&quot;&gt;註冊帳號&lt;/h2&gt;\n      &lt;input\n        className=&quot;formControls_input&quot;\n        type=&quot;email&quot;\n        id=&quot;email&quot;\n        placeholder=&quot;請輸入 email&quot;\n        &#123;...register(&quot;email&quot;)&#125;\n      /&gt;\n\n      &lt;input\n        className=&quot;formControls_input&quot;\n        type=&quot;text&quot;\n        id=&quot;nickname&quot;\n        placeholder=&quot;請輸入您的暱稱&quot;\n        &#123;...register(&quot;nickname&quot;)&#125;\n      /&gt;\n\n      &lt;input\n        className=&quot;formControls_input&quot;\n        type=&quot;password&quot;\n        id=&quot;password&quot;\n        placeholder=&quot;請輸入密碼&quot;\n        &#123;...register(&quot;password&quot;)&#125;\n      /&gt;\n\n      &lt;button className=&quot;formControls_btnSubmit&quot; type=&quot;submit&quot;&gt;\n        註冊帳號\n      &lt;/button&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n);補充：從以上範例中，當我們填寫好 input 並送出表單後，就能從自定義函式的 data 參數中取得資料。\njs// 自定義的 submit\nconst onSubmit = (data) =&gt; &#123;\n  console.log(data);\n  // &#123;email: &#39;我們所填入的 mail&#39;, nickname: &#39;填入的 nickname&#39;, password: &#39;填入的密碼&#39;&#125;\n&#125;;使用心得這週上課時，中途有提到表單處理，雖然 React 在資料處理上有一些固定的模式，但不得不說是比較複雜的（很吃 JS 底子）。\n這次作業的表單是較為單純的（欄位少），所以即使不用這個套件，對於速度跟方便性上也不會差異太多；不過透過這樣的嘗試，可以知道如果是複雜表單（欄位多），就相當適合導入使用，而這個套件也包含了一些方便的功能，像是狀態監聽、錯誤樣式、驗證等等。\nAxios 的 API 管理當我們使用 axios 來串接 api 時，可以試著把 api crud 的相關操作都集中在一支 js 檔案管理，需要某個 api 操作時再引用出來，這樣的概念跟優點可以參考 Mike老師的文章。\n自己最早接觸到這樣的概念是幾年前的某次面試，那時跟負責面試的技術主管討論了工作上的專案，以及聊到了在 Vue 直播班做的作品（2020的直播班），而這位主管在面試快結束時，也給予我一些建議，像是可以鑽研 vue 的底層知識、vue2 到 vue3 的不同，以及 api 抽出來管理（真的很感謝那位技術主管）。雖然這次課程用到的 api 數量不多，所以即使沒有管理也是 OK 的，不過還是借著這樣的機會來做練習。\n抽出 api 程式\n看了 api 操作有哪些之後，從專案根目錄開一個 api folder，並在裡頭新增 index.js\n首先 import axios 到這支檔案中，並透過 axios.create 創建 axios 的實體\n雖然這次只用到 baseURL，不過還是可以看一下文件的 config\n\n\n把 api 的 crud 操作包裝在函式內，並 export 出去。這邊也先根據 api 文件去配置需要的參數，像是 data、id、headers\n在函式命名上我以 api 做開頭，表示這是處理 api 相關\n\n\n\njs// api/index.js\nimport axios from &quot;axios&quot;;\n\nconst todoBase = axios.create(&#123;\n  baseURL: &quot;https://...&quot;,\n&#125;);\n\n// 註冊\nexport const apiUsersSignUp = (data) =&gt; todoBase.post(&quot;/users/sign_up&quot;, data);\n\n// 登入\nexport const apiUsersSignIn = (data) =&gt; todoBase.post(&quot;/users/sign_in&quot;, data);\n\n// 驗證\nexport const apiUsersCheckout = (headers) =&gt;\n  todoBase.get(&quot;/users/checkout&quot;, headers);\n\n// 登出\nexport const apiUsersSignOut = (headers) =&gt;\n  todoBase.post(&quot;/users/sign_out&quot;, &#123;&#125;, headers);\n\n// 取得所有待辦\nexport const apiGetTodos = (headers) =&gt; todoBase.get(&quot;/todos/&quot;, headers);\n\n// 新增待辦\nexport const apiPostTodos = (data, headers) =&gt;\n  todoBase.post(&quot;/todos/&quot;, data, headers);\n\n// 刪除待辦\nexport const apiDeleteTodos = (id, headers) =&gt;\n  todoBase.delete(`/todos/$&#123;id&#125;`, headers);\n\n// 切換待辦狀態\nexport const apiPatchTodos = (id, headers) =&gt;\n  todoBase.patch(`/todos/$&#123;id&#125;/toggle`, &#123;&#125;, headers);\n\n// 編輯待辦文字\nexport const apiPutTodos = (id, data, headers) =&gt;\n  todoBase.put(`/todos/$&#123;id&#125;`, data, headers);\n引用再來以新增項目跟刪除項目來做個範例：\n\n首先從 api&#x2F;index.js 引用我們需要的 api 函式，這個範例是新增跟刪除項目的函式\n新增項目：在 addTodo 中去使用 apiPostTodos 這個操作，並帶上需要的 data(input value) 跟 headers(token)。後面一樣可接上 .then().catch()\n刪除項目：在 deleteTodo 中去使用 apiDeleteTodos 這個操作，並帶上需要的 id(要刪除哪一筆) 跟 headers\n\n（範例中為了說明主要內容，所以會省略較多程式碼）\njsx// Todo.jsx\n// ...略\nimport &#123;\n  apiPostTodos,\n  apiDeleteTodos,\n&#125; from &quot;../api&quot;;\n\n\nconst Todo = (&#123; todoToken &#125;) =&gt; &#123;\n  // ...略\n  const [input, setInput] = useState(&quot;&quot;);\n\n  const headers = &#123;\n    Authorization: todoToken,\n  &#125;;\n\n  // ...略\n\n  // 新增項目\n  const addTodo = () =&gt; &#123;\n    if (input === &quot;&quot;) return;\n    apiPostTodos(&#123; content: input &#125;, &#123; headers &#125;).then((res) =&gt; &#123;\n      console.log(res);\n    &#125;);\n\n    setInput(&quot;&quot;); // 清空\n    getTodos();\n  &#125;;\n\n  // 刪除項目\n  const deleteTodo = (id) =&gt; &#123;\n    apiDeleteTodos(id, &#123; headers &#125;);\n    getTodos();\n  &#125;;\n  // ... 略\n&#125;;\n\nexport default Todo;\n題外話跟補充雖然知道 Async&#x2F;Await 這個寫法在視覺上比較好讀，但不曉得為何自己一直都很習慣用 .then().catch() 的形式。補充：如果不是用 axios 來串接 api，也是可以做到管理的，不過要自己多寫些程式封裝。\n關於 API 串接練習在寫這篇文的過程中，也看到老師在公告中，建議同學盡量練習課程所提供的 API。我覺得這樣的練習相當重要，除了 AJAX 是前端的必須技能外，我也想分享這幾年在前端工作的心得。\n前端工程師的職務內容，在不同公司跟產業中是差異很大的，再加上團隊氛圍等多種因素的影響。有的公司很重視切版、畫面，有的則很注重程式，有些時候也會被指派一些跟前端無關的任務。以我自己上一份工作經驗來說，大約有 10% 到 20% 的時間會做非程式任務，20% 的時間會處理一些後端部分（例如將表單資料送入資料庫），而剩下的部分才回到前端領域。（補充：這個段落不是抱怨，而是接受每個公司對前端需求是不同的，主要是當事者能否接受）\n由於公司的類型多樣，比如團隊是否有前後端分離，或者專案的時辰充裕與否，再加總一些其他因素等等，我們不一定能在工作上串接到後端提供的 API，再來是不一定會有這麼詳盡的文件（甚至沒有文件）。所以如第一個段落所述，會覺得這樣的練習是很重要。（當然也有一些第三方服務是可以串接練習的）\n\n結尾第三週作業如果寫的較為完整，就可以好好來銜接最終作業了。不曉得為何，這週寫作業時，腦袋會比較頻繁的當機，所以都要提醒自己起來動一動，做點不同的事情。\n最近回來寫程式的過程（復健），一直能感覺到過去累積不少技術債，這陣子先專心在規劃好的任務上，之後再來還債了（例如：JS 核心）。\n（若有什麼部分寫錯，也再麻煩跟我說，感恩！）\n","slug":"react-workshop-week3","date":"2023-08-27T16:00:00.000Z","categories_index":"前端","tags_index":"六角學院,React","author_index":"Billy's blog"},{"id":"c70138af58866b2a7da79e23c700a92e","title":"在 Nuxt3 使用 Bootstrap5","content":"前言近期正在練習把 Vue2 的舊專案翻成 Nuxt3，因為過去這個專案是使用 Bootstrap4，想說就順道升上 Bootstrap5。不過 Nuxt3 跟 Bootstrap5 並沒有一個整合好的套件（例如：BootstrapVue），所以在引用上就會多一些設置。\n（一開始在考慮 Nuxt3 的套件整合上，本來是有考慮翻到 Tailwind，不過考慮到重切時間跟專注度，決定還是先專心熟悉 Nuxt3）\n\n設置部分CDN 配置這邊先提一個最簡易的配置，如果只是做個 Demo，沒有要使用到客製化，那麽就可以在 nuxt.config.ts 直接引入 CDN 使用。\nts// nuxt.config.ts\nimport &#123; defineNuxtConfig &#125; from &#39;nuxt&#39;\nexport default defineNuxtConfig(&#123;\n  app: &#123;\n    head: &#123;\n      link: [\n        &#123; rel: &#39;stylesheet&#39;, href: &#39;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css&#39;, integrity: &#39;sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU&#39;, crossorigin: &#39;anonymous&#39; &#125;\n      ],\n      script: [\n        &#123; src: &#39;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&#39;, integrity: &#39;sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ&#39;, crossorigin: &#39;anonymous&#39; &#125;\n      ]\n    &#125;\n  &#125;\n&#125;)安裝先在專案的終端機中，輸入以下 npm install bootstrap @popperjs/core。Popper.js 是跟一些 Bootstrap5 效果如 popper、tooltip 有關。\ncss 設置我們可以在 nuxt.config.ts 的設置中，直接引入 bootstrap.scss，當然這樣就無法去客製；\n這邊是在 assets 創建一個 main.scss，然後 @import &quot;./variables&quot;; 這個部分是從 node_module bootstrap 複製過來的，這樣就可以去客製一些 bootstrap 變數（例如：顏色、距離等等）。然後也能帶上自己要寫的 scss。\nts// nuxt.config.ts\nimport &#123; defineNuxtConfig &#125; from &#39;nuxt&#39;\nexport default defineNuxtConfig(&#123;\n  css: [\n    // &#39;bootstrap/scss/bootstrap.scss&#39;,\n    &#39;@/assets/styles/main.scss&#39;,\n  ],\n&#125;);\nscss// main.scss\n@import &quot;bootstrap/scss/functions&quot;;\n@import &quot;./variables&quot;;\n@import &quot;bootstrap/scss/bootstrap&quot;;\n\n@import &quot;./common&quot;;\n@import &quot;./page/prod&quot;;\n@import &quot;./page/home&quot;;\n// ... 略JS 的設置在 Nuxt 專案的根目錄中，創建 plugins 的資料夾，並且新建一支 JS 檔案，這邊範例是用 useBootstrap.client.js 作為命名。\n接下來把 node_module 中的 bootstrap.bundle.js 給引用進來，接著 nuxtApp.provide(&quot;bootstrap&quot;, bootstrap) 將 bootstrap.bundle.js 的功能引用到 Nuxt 中。\njs// useBootstrap.client.js\nimport bootstrap from &quot;bootstrap/dist/js/bootstrap.bundle&quot;;\n\nexport default defineNuxtPlugin((nuxtApp) =&gt; &#123;\n    nuxtApp.provide(&quot;bootstrap&quot;, bootstrap);\n&#125;);接著我們可以透過 const &#123; $bootstrap &#125; = useNuxtApp() 來使用 bootstrap js，記得要加上 $ 符號。以下範例示意，當去打 api 拿回資料後，才去觸發 Modal：\nhtml&lt;script setup&gt;\n\n// bootstrap js\nconst &#123; $bootstrap &#125; = useNuxtApp();\n\n// ... 其他程式略\n\n$fetch(api, &#123;\n  method: &quot;GET&quot;,\n  headers: headers,\n&#125;)\n  .then((res) =&gt; &#123;\n    const &#123; data &#125; = res;\n    // ... 略\n    productModalHandle.show();\n  &#125;)\n    \nonMounted(() =&gt; &#123;\n  productModalHandle = new $bootstrap.Modal(productModal.value, &#123;&#125;); // 記得綁上 ref\n  delProductModalHandle = new $bootstrap.Modal(delProductModal.value, &#123;&#125;);\n&#125;);\n&lt;/script&gt;\n\n結尾以上是參考這篇 stackoverflow，並做個延伸。\n如果有遇到 sass 的 abs 警告，則可以試著把 sass 的版本降低。\n","slug":"nuxt3-install-bootstrap5","date":"2023-08-23T16:00:00.000Z","categories_index":"前端","tags_index":"Nuxt3,Bootstrap5","author_index":"Billy's blog"},{"id":"397b38190a0df3f421c0792c403d2b3d","title":"六角學院 React 入門工作坊第二週","content":"Photo by Lautaro Andreani on Unsplash\n前言本週心得小提：課程除了可以學習到 React 操作，還可以從老師怎麼拆解問題，以及同學的程式碼中（有些同學感覺是有經驗的開發者），去看到不同的思路，擴展出解決問題的眼界。\n記得這週課程快結尾時，老師有提到工程師的差異，厲害的工程師是會把複雜轉為簡單，以清楚的方式撰寫程式碼（取代很潮、炫技），聽到這個段落，覺得特別有感。\n第二週作品\n大致的流程為：\n\n思考資料與切版（練習 Tailwind）\n程式邏輯撰寫 \n拆元件\n\n\n思考資料與切版（練習 Tailwind）在開始動工之前，先來初步釐清會有什麼資料（功能）：\n\n菜單資料\n\nconst [menu] = useState(data)，放進 data 初始資料\n根據菜單的點擊，會帶 id、品項、描述、單價等等資料到購物車\n同一品項重覆點選時（該品項已經存在購物車），則在購物車資料中，將該品項數量 + 1\n\n\n購物車資料\n\nconst [cart, setCart] = useState([])，初始購物車為空 Array\n除了菜單帶過來的資料外，也要多定義數量 qty 跟小計（數量*價錢）\n刪除品項跟更新品項數量的功能\n定義購物價錢總計 const [sum, setSum] = useState(0)\n備註 const [note, setNote] = useState(&quot;&quot;); \n點擊送出訂單時，會帶購物車資料到訂單\n\n\n訂單資料： \n\nconst [order, setOrder] = useState([])，初始為空 Array\n除了從購物車帶過來的資料，也多定義一個 id\n\n\n\n切版：因為先前的工作內容，所以較常在手刻畫面；不過近期回來接觸前端後，有時候反而會思考，有沒有什麼方式可以減少切版的時間（可能是開始想懶惰了?）。記得幾個月前還有看到一個付費的功能，是把 figma 的設計圖，轉換成 react 的程式碼。藉由這樣的實作機會跟想法，決定嘗試使用 Tailwind，記得 JIT 模式剛出時有稍微接觸過。本來預期習慣 Tailwind 不會花太多時間，不過實際上還是花了不少時間。（也有去找人家寫好的 UI 來改）\n程式邏輯撰寫因為切版後的程式行數沒有很多(2xx)，所以就沒有先拆元件。\n將 menu 定義到畫面上jsxconst App = () =&gt; &#123;\n  const [menu] = useState(data); // 原始 menu\n  \n  return (\n    // ...略\n    &lt;ul className=&quot;flex flex-wrap -mx-3&quot;&gt;\n      &#123;menu.map((item) =&gt; &#123;\n        return (\n          &lt;li key=&#123;item.id&#125; className=&quot;md:w-1/2 w-full px-3 pb-6&quot;&gt;\n            &lt;div className=&quot;rounded-lg border-2 p-3 cursor-pointer border-brown-light hover:bg-brown-100&quot;&gt;\n              &lt;h3 className=&quot;text-xl text-brown font-medium&quot;&gt;\n                &#123;item.name&#125; &lt;span&gt;$&#123;item.price&#125;&lt;/span&gt;\n              &lt;/h3&gt;\n              &lt;p className=&quot;mt-1 text-md text-brown&quot;&gt;\n                &#123;item.description&#125;\n              &lt;/p&gt;\n            &lt;/div&gt;\n          &lt;/li&gt;\n        );\n      &#125;)&#125;\n    &lt;/ul&gt;\n    // ...略\n  )\n\n&#125;\n選擇飲品點擊時，將資料帶入購物車\n購物車資料預設為 []\n在選擇飲品的 List，新增 onClick 事件觸發 addCart，並在參數中帶上資料 (menu item)\n在 addCart function 做一個 tempCart 的新陣列，並多帶上預設數量 qty\n\njsxconst App = () =&gt; &#123;\n  const [menu] = useState(data); // 原始 menu\n  const [cart, setCart] = useState([]); // 購物車資料\n\n  const addCart = (item) =&gt; &#123;\n    const tempCart = [\n      ...cart, // [] 淺拷貝\n      &#123;\n        ...item,\n        qty: 1, // 數量預設為 1\n      &#125;,\n    ];\n    setCart(tempCart);\n  &#125;;\n\n  return (\n    // ...略\n    &lt;ul className=&quot;flex flex-wrap -mx-3&quot;&gt;\n      &#123;menu.map((item) =&gt; &#123;\n        return (\n          &lt;li\n            key=&#123;item.id&#125;\n            className=&quot;md:w-1/2 w-full px-3 pb-6&quot;\n            onClick=&#123;() =&gt; addCart(item)&#125;\n          &gt;\n            &lt;div className=&quot;rounded-lg border-2 p-3 cursor-pointer border-brown-light hover:bg-brown-100&quot;&gt;\n              &lt;h3 className=&quot;text-xl text-brown font-medium&quot;&gt;\n                &#123;item.name&#125; &lt;span&gt;$&#123;item.price&#125;&lt;/span&gt;\n              &lt;/h3&gt;\n              &lt;p className=&quot;mt-1 text-md text-brown&quot;&gt;\n                &#123;item.description&#125;\n              &lt;/p&gt;\n            &lt;/div&gt;\n          &lt;/li&gt;\n        );\n      &#125;)&#125;\n    &lt;/ul&gt;\n    // ... 略\n  )\n\n&#125;購物車資料定義到畫面當我們可以透過點擊飲品，把飲品項目加到購物車，接著把購物車資料定義到畫面中。（可以透過 React Developer Tools 工具來看資料）\njsxconst App = () =&gt; &#123;\n  const [menu] = useState(data); // 原始 menu\n  const [cart, setCart] = useState([]); // 購物車資料\n\n  const addCart = (item) =&gt; &#123;\n    const tempCart = [\n      ...cart, // [] 淺拷貝\n      &#123;\n        ...item,\n        qty: 1, // 數量預設為 1\n      &#125;,\n    ];\n    setCart(tempCart);\n  &#125;;\n\n    return (\n    // ...略\n    &lt;tbody&gt;\n      &#123;cart.map((item) =&gt; &#123;\n        return (\n          &lt;tr key=&#123;item.id&#125;&gt;\n            &lt;td className=&quot;p-3 border-b border-dashed border-brown-light&quot;&gt;\n              &lt;h3 className=&quot;text-xl text-brown font-medium&quot;&gt;\n                &#123;item.name&#125;\n              &lt;/h3&gt;\n              &lt;p className=&quot;mt-1 text-md text-brown&quot;&gt;\n                &#123;item.description&#125;\n              &lt;/p&gt;\n              &lt;button\n                type=&quot;button&quot;\n                className=&quot;mt-2 text-red-400 text-sm&quot;\n              &gt;\n                刪除品項\n              &lt;/button&gt;\n            &lt;/td&gt;\n            &lt;td className=&quot;p-3 border-b border-dashed border-brown-light text-center text-md text-brown w-32&quot;&gt;\n              &lt;select\n                name=&quot;&quot;\n                id=&quot;&quot;\n                className=&quot;w-1/2 h-[32px] rounded-md text-center bg-brown-100 focus:outline-none focus:border-brown-dark&quot;\n                value=&#123;item.qty&#125;\n              &gt;\n                &#123;[...Array(10).keys()].map((item) =&gt; &#123;\n                  return (\n                    &lt;option value=&#123;item + 1&#125; key=&#123;item&#125;&gt;\n                      &#123;item + 1&#125;\n                    &lt;/option&gt;\n                  );\n                &#125;)&#125;\n              &lt;/select&gt;\n            &lt;/td&gt;\n            &lt;td className=&quot;p-3 border-b border-dashed border-brown-light text-center text-md text-brown&quot;&gt;\n              &#123;item.price&#125;\n            &lt;/td&gt;\n            &lt;td className=&quot;p-3 border-b border-dashed border-brown-light text-center text-md text-brown&quot;&gt;\n              &#123;item.price * item.qty&#125;\n            &lt;/td&gt;\n          &lt;/tr&gt;\n        );\n      &#125;)&#125;\n    &lt;/tbody&gt;\n  )\n\n&#125;判斷購物車是否為空以 cart.length === 0 來判斷要顯示的畫面\njsx&#123; cart.length === 0 \n  ? (\n  &lt;div className=&quot;rounded-lg border-2 border-brown-light mt-4 p-4 text-center text-brown font-bold&quot;&gt;\n    尚未選擇飲品～\n  &lt;/div&gt;\n  ) : (\n    // ... 略\n    &#123;cart.map((item) =&gt; &#123;\n      return (\n        &lt;tr key=&#123;item.id&#125;&gt;\n          &lt;td className=&quot;p-3 border-b border-dashed border-brown-light&quot;&gt;\n            &lt;h3 className=&quot;text-xl text-brown font-medium&quot;&gt;\n              &#123;item.name&#125;\n            &lt;/h3&gt;\n            &lt;p className=&quot;mt-1 text-md text-brown&quot;&gt;\n              &#123;item.description&#125;\n            &lt;/p&gt;\n            &lt;button\n              type=&quot;button&quot;\n              className=&quot;mt-2 text-red-400 text-sm&quot;\n            &gt;\n              刪除品項\n            &lt;/button&gt;\n          &lt;/td&gt;\n          // ... 略\n        &lt;/tr&gt;\n      );\n    &#125;)&#125;\n  )\n&#125;重覆點選飲品的判斷當我們點擊飲品，觸發飲品項目加到購物車時，還需判斷購物車中是否已經有此飲品品項，所以會以 id 作為判斷依據。\n程式上先以 const conformIndex = cart.findIndex((cartItem) =&gt; item.id === cartItem.id); 來做判斷，對比飲品品項的 id 跟購物車 id。 (-1 表示購物車還沒有這個品項)\n購物車沒有此品項時，就跑原本的新增程式；如果已經有此品項，就跑編輯的程式，編輯的寫法跟上週是一樣的，這邊就不再贅述。\njsxconst addCart = (item) =&gt; &#123;\n  const conformIndex = cart.findIndex((cartItem) =&gt; item.id === cartItem.id);\n\n  if (conformIndex === -1) &#123;\n    // -1 表示購物車還沒有這個品項\n    const tempCart = [\n      ...cart, // [] 淺拷貝\n      &#123;\n        ...item,\n        qty: 1, // 數量預設為 1\n      &#125;,\n    ];\n    setCart(tempCart);\n  &#125; else &#123;\n    // 購物車原先就有此品項\n    const tempCart = cart.map((cartItem) =&gt; &#123;\n      return item.id === cartItem.id\n        ? &#123;\n            ...cartItem,\n            qty: cartItem.qty &lt; 10 ? cartItem.qty + 1 : cartItem.qty,\n          &#125;\n        : &#123; ...cartItem &#125;;\n    &#125;);\n    setCart(tempCart);\n  &#125;\n&#125;;購物車總計先定義 const [total, setTotal] = useState(0); 總計資料，然後透過 useEffect 來觀察購物車是否有更動，只要更動就透過 reduce 重新計算總價。（這邊就省略把 total 放到畫面上）\njsxconst App = () =&gt; &#123;\n    const [menu] = useState(data); // 原始 menu\n    const [cart, setCart] = useState([]); // 購物車資料\n    const [total, setTotal] = useState(0); // 總計\n\n  // ... 略\n  useEffect(() =&gt; &#123;\n        const totalPrice = cart.reduce((prev, curr) =&gt; &#123;\n            return prev + curr.price * curr.qty;\n        &#125;, 0);\n        setTotal(totalPrice);\n    &#125;, [cart]);\n\n  return (\n    //...略\n  )\n購物車品項更改數量 (select)如果我們在 select 綁上 value ，但並沒有綁上 onChange 的功能時，雖然程式並不會整個爆掉，但會噴紅字加上不能操作 select。\n所以在這邊加上 updateCart 的功能，記得帶上 e.target.value。\njsxconst App = () =&gt; &#123;\n  const [menu] = useState(data); // 原始 menu\n  const [cart, setCart] = useState([]); // 購物車資料\n  const [total, setTotal] = useState(0); // 總計\n\n  // ... 略\n\n  const updateCart = (item, value) =&gt; &#123;\n    const tempCart = cart.map((cartItem) =&gt; &#123;\n      return item.id === cartItem.id\n        ? &#123;\n            ...cartItem,\n            qty: Number(value),\n          &#125;\n        : &#123; ...cartItem &#125;;\n    &#125;);\n    setCart(tempCart);\n  &#125;;\n\n  return (\n    // ... 略\n    &lt;td className=&quot;p-3 border-b border-dashed border-brown-light text-center text-md text-brown w-32&quot;&gt;\n      &lt;select\n        name=&quot;&quot;\n        id=&quot;&quot;\n        className=&quot;w-1/2 h-[32px] rounded-md text-center bg-brown-100 focus:outline-none focus:border-brown-dark&quot;\n        value=&#123;item.qty&#125;\n        onChange=&#123;(e) =&gt; updateCart(item, e.target.value)&#125;\n      &gt;\n        &#123;[...Array(10).keys()].map((item) =&gt; &#123;\n          return (\n            &lt;option value=&#123;item + 1&#125; key=&#123;item&#125;&gt;\n              &#123;item + 1&#125;\n            &lt;/option&gt;\n          );\n        &#125;)&#125;\n      &lt;/select&gt;\n    &lt;/td&gt;\n    // ...略\n  )\n&#125;\n刪除購物車品項那時上課時，看到用 filter 來處理刪除功能，還是會有點反應不上來，雖然並不是第一次看到這樣操作。\n筆記：item.id === cartItem.id 表示符合條件的只有一筆；所以反過來寫的話，就是除了這一筆之外的資料都要留著。（畫面略)\njsxconst deleteCartItem = (item) =&gt; &#123;\n  const tempCart = cart.filter((cartItem) =&gt; &#123;\n    return item.id !== cartItem.id;\n  &#125;);\n  setCart(tempCart);\n&#125;;創建訂單當我們點擊購物列表的送出按鈕後，會去觸發 createOder function。\n\n定義資料 const [order, setOrder] = useState([]);\n在 tempOrder 這個 array 中，除了帶上購物車、備註、總計的資料外，也多定義一個 id\n最後記得清空購物車跟備註資料\n\njsxconst App = () =&gt; &#123;\n  const [menu] = useState(data); // 原始 menu\n  const [cart, setCart] = useState([]); // 購物車資料\n  const [total, setTotal] = useState(0); // 總計\n  const [note, setNote] = useState(&quot;&quot;); // 備註\n  const [order, setOrder] = useState([]); // 訂單\n\n  // ... 略\n\n  const createOder = () =&gt; &#123;\n    const tempOrder = [\n      ...order, \n      &#123;\n        id: new Date().getTime(),\n        cart,\n        note,\n        total,\n      &#125;,\n    ];\n\n    setOrder(tempOrder);\n    setCart([]);\n    setNote(&quot;&quot;);\n  &#125;;\n&#125;定義訂單到畫面先用 order.length === 0 判斷要顯示什麼畫面。接著把資料帶到畫面中。\njsx  &lt;div className=&quot;mx-auto lg:w-3/5 w-full&quot;&gt;\n    &#123;/* 訂單  */&#125;\n    &#123;order.length === 0 ? (\n      &lt;div className=&quot;rounded-lg border-2 border-brown-light mt-4 p-4 text-center text-brown font-bold&quot;&gt;\n        尚未建立訂單～\n      &lt;/div&gt;\n    ) : (\n      order.map((item) =&gt; &#123;\n        return (\n          &lt;div\n            className=&quot;rounded-lg border-2 border-brown-light mt-4 p-4 text-brown text-center&quot;\n            key=&#123;item.id&#125;\n          &gt;\n            &lt;h2 className=&quot;text-2xl font-bold text-primary text-left&quot;&gt;\n              訂單\n            &lt;/h2&gt;\n            &lt;p className=&quot;mt-1 text-md text-brown text-left&quot;&gt;\n              編號：&#123;item.id&#125;\n            &lt;/p&gt;\n            &lt;p className=&quot;mt-1 text-md text-brown text-left&quot;&gt;\n              備註：&#123;item.note&#125;\n            &lt;/p&gt;\n            &lt;div className=&quot;mt-2 mb-4&quot;&gt;\n              &lt;table className=&quot;w-full&quot;&gt;\n                &lt;thead className=&quot;border-b-2 border-brown-light&quot;&gt;\n                  &lt;tr&gt;\n                    &lt;th className=&quot;p-3 font-medium text-brown&quot;&gt;品項&lt;/th&gt;\n                    &lt;th className=&quot;p-3 font-medium text-brown&quot;&gt;數量&lt;/th&gt;\n                    &lt;th className=&quot;p-3 font-medium text-brown&quot;&gt;小計&lt;/th&gt;\n                  &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody className=&quot;&quot;&gt;\n                  &#123;item.cart.map((innerItem) =&gt; &#123;\n                    return (\n                      &lt;tr\n                        key=&#123;innerItem.id&#125;\n                        className=&quot;border-b border-brown-light&quot;\n                      &gt;\n                        &lt;td className=&quot;p-3 text-brown&quot;&gt;\n                          &#123;innerItem.name&#125;\n                        &lt;/td&gt;\n                        &lt;td className=&quot;p-3 text-brown&quot;&gt;\n                          &#123;innerItem.qty&#125;\n                        &lt;/td&gt;\n                        &lt;td className=&quot;p-3 text-brown&quot;&gt;\n                          &#123;innerItem.qty * innerItem.price&#125;\n                        &lt;/td&gt;\n                      &lt;/tr&gt;\n                    );\n                  &#125;)&#125;\n                &lt;/tbody&gt;\n                &lt;tfoot&gt;\n                  &lt;tr&gt;\n                    &lt;td colSpan=&quot;2&quot;&gt;&lt;/td&gt;\n                    &lt;td colSpan=&quot;1&quot; className=&quot;p-3&quot;&gt;\n                      &lt;h3 className=&quot;text-center text-xl text-brown font-medium&quot;&gt;\n                        總計: $&#123;item.total&#125;\n                      &lt;/h3&gt;\n                    &lt;/td&gt;\n                  &lt;/tr&gt;\n                &lt;/tfoot&gt;\n              &lt;/table&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        );\n      &#125;)\n    )&#125;\n  &lt;/div&gt;拆元件處理好程式邏輯後，再來就是拆元件的部分，這邊就先拆出最基準的三個（Menu、Cart、Order）。\n在拆元件之前，因為 ESLint 會提醒 props 的型別宣告，所以要先安裝 prop-types。\n以 Cart 為範例這邊就以購物車的元件作為主要範例，其他元件拆法都是一致的。首先我們先在 src 新增 components 資料夾，並新增元件(Cart.jsx)。\n接著在 Cart.jsx 先建好預設，並 import propTypes 以及預設 propTypes 物件：\njsx// Cart.jsx\nimport propTypes from &quot;prop-types&quot;;\n\nconst Cart = () =&gt; &#123;\n  return ()\n&#125;\n\nCart.propTypes = &#123;\n    \n&#125;;\n\nexport default Cart;將 App.jsx 中的購物車內容，移動到 Cart.jsx 的樣板中。然後在 App.jsx 引入 Cart.jsx\njsx// Cart.jsx\nimport propTypes from &quot;prop-types&quot;;\nconst Cart = () =&gt; &#123;\nreturn (\n  &lt;div className=&quot;&quot;&gt;\n    &#123;/* 購物車 */&#125;\n    &lt;h2 className=&quot;text-2xl font-bold text-primary&quot;&gt;購物列表&lt;/h2&gt;\n    &lt;hr className=&quot;mt-2 mb-4&quot; /&gt;\n    &#123;cart.length === 0 ? (\n      &lt;div className=&quot;rounded-lg border-2 border-brown-light mt-4 p-4 text-center text-brown font-bold&quot;&gt;\n        尚未選擇飲品～\n      &lt;/div&gt;\n    ) : (\n      &lt;div className=&quot;rounded-lg border-2 border-brown-light mt-4 p-4&quot;&gt;\n        &lt;table className=&quot;min-w-full leading-normal&quot;&gt;\n          &lt;thead&gt;\n            &lt;tr&gt;\n              &lt;th className=&quot;p-3 text-left text-xs font-semibold text-brown-light&quot;&gt;\n                飲品資訊\n              &lt;/th&gt;\n              &lt;th className=&quot;p-3 text-center text-xs font-semibold text-brown-light&quot;&gt;\n                數量\n              &lt;/th&gt;\n              &lt;th className=&quot;p-3 text-center text-xs font-semibold text-brown-light&quot;&gt;\n                單價\n              &lt;/th&gt;\n    // ... 以下略\n);\n&#125;;\njsx// App.jsx\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport Cart from &quot;@/components/Cart&quot;;\n// ... 略\n\nconst App = () =&gt; &#123;\n  // ... 略\n  return (\n    &lt;div className=&quot;bg-[#F8F6F2] min-h-screen&quot;&gt;\n      &lt;div className=&quot;container mx-auto px-3 py-8&quot;&gt;\n        &lt;div className=&quot;grid grid-cols-1 gap-4 lg:grid-cols-2 lg:gap-8&quot;&gt;\n          // 略 ...\n          &lt;Cart /&gt;\n        &lt;/div&gt;\n        &lt;hr className=&quot;mt-4 mb-6&quot; /&gt;\n        // ...略\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;\n在 Cart.jsx 定義好預計要傳過來的資料跟功能，如下圖所示，我們可以根據紅字（沒有定義）來知道預計要傳過來的資料跟功能。接著透過 Cart.propTypes 定義好要傳進來的資料型別、功能\n\njsx// Cart.jsx\nimport propTypes from &quot;prop-types&quot;;\nconst Cart = (&#123; cart, deleteCartItem, updateCart, total, note, setNote,\ncreateOder &#125;) =&gt; &#123;\n  return (\n    &lt;div className=&quot;&quot;&gt;\n      &#123;/* 購物車 */&#125;\n      &lt;h2 className=&quot;text-2xl font-bold text-primary&quot;&gt;購物列表&lt;/h2&gt;\n      &lt;hr className=&quot;mt-2 mb-4&quot; /&gt;\n    // ... 略\n  )\n&#125;\n\nCart.propTypes = &#123;\n  cart: propTypes.array.isRequired,\n  deleteCartItem: propTypes.func.isRequired,\n  updateCart: propTypes.func.isRequired,\n  total: propTypes.number.isRequired,\n  note: propTypes.string.isRequired,\n  setNote: propTypes.func.isRequired,\n  createOder: propTypes.func.isRequired,\n&#125;;根據在 Cart.jsx 所需要的資料或功能，我們就可以從父層傳入相對應的資料跟功能。\njsx// app.jsx\nimport Cart from &quot;@/components/Cart&quot;;\n// ...略\n\nconst App = () =&gt; &#123;\n  // ... 略\n  return (\n    &lt;div className=&quot;bg-[#F8F6F2] min-h-screen&quot;&gt;\n      &lt;div className=&quot;container mx-auto px-3 py-8&quot;&gt;\n        &lt;div className=&quot;grid grid-cols-1 gap-4 lg:grid-cols-2 lg:gap-8&quot;&gt;\n          // ... 略\n          &lt;Cart\n            cart=&#123;cart&#125;\n            deleteCartItem=&#123;deleteCartItem&#125;\n            updateCart=&#123;updateCart&#125;\n            total=&#123;total&#125;\n            note=&#123;note&#125;\n            setNote=&#123;setNote&#125;\n            createOder=&#123;createOder&#125;\n          /&gt;\n        &lt;/div&gt;\n        &lt;hr className=&quot;mt-4 mb-6&quot; /&gt;\n        // ... 略\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\n結尾現在在寫 React 時，都特別能感受自己原生 JS 的不足，雖然能寫出程式，不過有時都會覺得卡卡的。先前寫 Vue 並不會這樣覺得，可能是因為 Vue 幫我們做了很多事（黑魔法）。\n在寫這週紀錄的結尾時，就在想第三週跟第四週可能會換種方式紀錄，雖然這樣的步驟拆解，可以讓我刻意練習思路；主要是考量到自己的其他規劃，不過目前倒還不曉得要改用什麼方式，也許下週就會有靈感了（？）。\n（若有什麼部分寫錯，也再麻煩跟我說，感恩！）\n","slug":"react-workshop-week2","date":"2023-08-18T16:00:00.000Z","categories_index":"前端","tags_index":"六角學院,React","author_index":"Billy's blog"},{"id":"89c83eb6ba1d8b6f84a22afbc3a7b375","title":"Pinia 筆記","content":"Pinia前言一段時間沒接觸前端領域，能很明顯感受到前端的變化如此之快。以 Vue 來說，透過官網提供的安裝 npm init vue@latest，也已經預設 vite 環境，以及把原先的 Vuex 改為 Pinia。\n目前正在複習 Vue ，這邊也把 Pinia 做個筆記，關於 Pinia 的特點：\n\n跟 Vuex 很像，都是作為狀態管理的工作\n沒有 Mutation （後來才知道有些開發者不喜歡這個步驟）\n簡潔定義\n可以寫 Option api ，也能寫 Composition api\n支援 Typescript \n可愛的官方吉祥物\n\n\n筆記基本使用先以 store&#x2F;counter.js 作為範例，我們需要先從 pinia 引入 defineStore 這個功能。\n如下範例，上方是用 composition api 的寫法，而下方是原本的 option 寫法 (Vuex 是這樣寫的)，兩種方式的選擇可依照自己所偏好的。在下方的範例中，將會以 composition api 的方式作筆記。\n對照：\n\n\n\nOption\nComposition\n\n\n\nstate\nref\n\n\ngetters\ncomputed\n\n\naction\nfunction\n\n\njsimport &#123; ref, computed &#125; from &#39;vue&#39;;\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\n// composition \nexport const useCounterStore = defineStore(&#39;counter&#39;, () =&gt; &#123;\n  const count = ref(0);\n  const doubleCount = computed(() =&gt; count.value * 2);\n  function increment() &#123;\n    count.value++\n  &#125;\n  return &#123; count, doubleCount, increment &#125;\n&#125;)\n  \n// option\nexport const useCounterStore = defineStore(&#123;\n  id: &quot;counter&quot;,\n  state: () =&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    doubleCount: (state) =&gt; state.counter * 2,\n  &#125;,\n  action: &#123;\n    addCount() &#123;\n      this.counter ++;\n    &#125;,\n  &#125;\n&#125;);在元件的引用中，先透過路徑 import useCounterStore 這個功能，然後再放到 store 這個變數。這邊因為使用了 script setup 這個語法糖，所以不用使用 return 就可在樣板中使用。\n（這支範例程式是 .vue 檔案，不過因為程式碼無法產生高亮反應，所以以 html 作為替代）\nhtml&lt;script setup&gt; \n  import &#123; ref &#125; from &#39;vue&#39;; \n  import &#123; useCounterStore &#125; from &quot;@/stores/counter.js&quot;; \n  const store = useCounterStore(); \n  const triggerStoreIncrement = () =&gt; &#123; \n    store.increment(); \n  &#125;\n&lt;/script&gt; \n&lt;template&gt; \n  &lt;h1&gt;Pinia&lt;/h1&gt; \n  pinia資料：&#123;&#123; store.count &#125;&#125; \n  &lt;button type=&quot;button&quot; @click=&quot;triggerStoreIncrement&quot;&gt;\n    觸發 pinia increment\n  &lt;/button&gt; \n&lt;/template&gt; \napi 的處理先前用 vuex 時，如果要打個 api，步驟是：\n\n元件做 dispatch \n在 action 打 api，並且 commit\n透過 commit 去觸發 mutation，然後改資料 (state)\n\n不過現在 pinia + composition api，變得比較簡潔（自由？），如下方程式碼所示：\njs// products.js\nimport &#123; ref &#125; from &#39;vue&#39;;\nimport axios from &quot;axios&quot;;\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useProductsStore = defineStore(&#39;product&#39;, () =&gt; &#123;\n  const products = ref([]);\n  const fetchApi = async() =&gt; &#123;\n    try &#123;\n      const res = await axios.get(&#39;https://fakestoreapi.com/products&#39;);\n      products.value = res.data;\n    &#125; catch (error) &#123;\n      // error\n    &#125;\n  &#125;\n  return &#123; products, fetchApi &#125;\n&#125;)\nhtml&lt;!-- products.vue --&gt;\n&lt;script setup&gt;\n  import &#123; useProductsStore &#125; from &quot;@/stores/products.js&quot;;\n  const store = useProductsStore();\n  const triggerStoreFetchApi = () =&gt; &#123;\n    store.fetchApi();\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;h1&gt;產品頁&lt;/h1&gt;\n  &lt;div&gt;&#123;&#123; store.products &#125;&#125;&lt;/div&gt;\n  &lt;button type=&quot;button&quot; @click=&quot;triggerStoreFetchApi&quot;&gt;Get API&lt;/button&gt;\n&lt;/template&gt;\n關於解構的可能問題當我們從元件去接 pinia 資料或方法時，可以透過解構達到更乾淨的 template，讓我們不用在 template 寫 store.xxxxxxx；不過如果是跟 ref 相關的資料 (ref、computed) ，解構會造成資料失去響應式，這時就可以用 pinia 提供的 storeToRefs()，來達成解構 ref 資料但不失去響應式。\n解構方面的問題，主要是對於 ref 相關資料；如果是 reactive 或函式就可以直接解構使用。\nhtml&lt;script setup&gt; \n  import &#123; ref &#125; from &#39;vue&#39;; \n  import &#123; useCounterStore &#125; from &quot;@/stores/counter.js&quot;; \n  const store = useCounterStore(); \n\n  const &#123; count &#125; = storeToRefs(store); \n  const &#123; increment &#125; = store; // 函式直接解構使用\n&lt;/script&gt; \n\n&lt;template&gt; \n  &lt;h1&gt;Pinia&lt;/h1&gt; \n  pinia資料：&#123;&#123; count &#125;&#125; \n  &lt;button type=&quot;button&quot; @click=&quot;increment&quot;&gt;\n    觸發 increment\n  &lt;/button&gt; \n&lt;/template&gt; \n\n","slug":"learn-pinia","date":"2023-08-13T16:00:00.000Z","categories_index":"前端","tags_index":"pinia","author_index":"Billy's blog"},{"id":"a837a7071ad4a7d5b4a13d7ee77d7277","title":"六角學院 React 入門工作坊第一週","content":"Photo by Lautaro Andreani on Unsplash\n前言因為身體關係，所以暫離了前端領域一段時間；而近期隨著身體已經趨於穩定（恢復中），所以想再度接回前端的軌道，目前保持進修中，也參加了六角開的 React 入門工作坊，增加與前端的連結。\n先前寫過 Vue 一段時間，所以在學習 React 時，能比較知道這兩者的一些比對，React 寫法的確比較自由，但很吃原生 JS 的功力（這方面偏弱QQ)，而這篇文章主要是想把第一週作業的過程，做點紀錄跟刻意練習寫程式的思路。\n作業放置處\n大致的流程為：\n\n定義資料並渲染\n調整庫存數量\n庫存數量優化\n編輯品項名稱\n\n\n定義資料並渲染不論使用哪個前端框架，我們都不是用 Dom 的角度做切入；而是採用資料驅動畫面的概念，所以定義資料、操作資料都是很常見的。\n使用 JSX 語法上，需要習慣一段時間。分享我自己的小撇步：在 JSX 語法中，如果要開始寫 JS 就用 {}；而準備要寫 HTML 就用 ()。（註：這是一個記憶撇步，實際上 JSX 內的概念就都是 JS）\njsconst &#123; useState &#125; = React;\n\nconst drinkMenu = [\n  // 略...\n];\n\nfunction MenuManage() &#123;\n  const [menu, setMenu] = useState(drinkMenu); // Hooks \n  \n  return (\n    &lt;div className=&quot;container&quot;&gt;\n      &lt;h1&gt;餐點管理工具&lt;/h1&gt;\n      &lt;table&gt;\n        // ...略\n        &lt;tbody&gt;\n          &#123;\n            menu.map((item) =&gt; &#123;\n              return (\n                &lt;tr key=&#123;item.id&#125;&gt;\n                  &lt;td&gt;&#123;item.name&#125;&lt;/td&gt;\n                  &lt;td&gt;&lt;small&gt;&#123;item.content&#125;&lt;/small&gt;&lt;/td&gt;\n                  &lt;td&gt;&#123;item.price&#125;&lt;/td&gt;\n                  &lt;td&gt;&#123;item.qty&#125;&lt;/td&gt;\n                &lt;/tr&gt; \n              )\n            &#125;)\n          &#125;\n        &lt;/tbody&gt;  \n      &lt;/table&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));\nroot.render(&lt;MenuManage /&gt;);\n調整庫存數量(考量到程式碼的長度，所以有些部分會做個省略)\n再來我們要調整庫存數量，所以做了兩個按鈕來對應增減的功能，而像是 () =&gt; handleQtyAdd(item.id)  所傳入的 item.id 則為識別用，判斷我們要改的是資料中的哪一個。 \n至於在庫存增加跟減少的功能中，我們得產出一組新的 array，然後再做 setState （下方範例是 setMenu），是因為 React state immutable 的設計概念。簡單來說就是寫 React 遇到要更新物件或陣列時，要根據更新需求去產新的物件或陣列。（有興趣的話可以 Google，或者參考這篇文章)。\njs\n// 前略...\n\nfunction MenuManage() &#123;\n  // Hooks 資料定義\n  const [menu, setMenu] = useState(drinkMenu);\n  \n  // 庫存增加\n  const handleQtyAdd = (id) =&gt; &#123; // id 為傳過來的參數，用於判斷現在點到是第幾個\n    const menuTemp = menu.map((item) =&gt; &#123;\n      return item.id === id \n        ? &#123; ...item, qty: (item.qty += 1) &#125; \n        : item;\n    &#125;);\n    setMenu(menuTemp);\n  &#125;\n  \n  // 庫存減少\n  const handleQtyMinus = (id) =&gt; &#123;\n    const menuTemp = menu.map((item) =&gt; &#123;\n      return item.id === id \n        ? &#123; ...item, qty: (item.qty -= 1) &#125; \n        : item;\n    &#125;);\n    setMenu(menuTemp);\n  &#125;\n\n  return (\n    &lt;div className=&quot;container&quot;&gt;\n      &lt;h1&gt;餐點管理工具&lt;/h1&gt;\n      &lt;table&gt;\n        // 略...\n        &lt;tbody&gt;\n          &#123;\n            menu.map((item) =&gt; &#123;\n              return (\n                &lt;tr key=&#123;item.id&#125;&gt;\n                  // 略...\n                  &lt;td&gt;\n                    &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleQtyMinus(item.id)&#125;&gt;-&lt;/button&gt;\n                    &#123;item.qty&#125;\n                    &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleQtyAdd(item.id)&#125;&gt;+&lt;/button&gt;\n                  &lt;/td&gt;\n                &lt;/tr&gt; \n              )\n            &#125;)\n          &#125;\n        &lt;/tbody&gt;  \n      &lt;/table&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));\nroot.render(&lt;MenuManage /&gt;);\n如果不太理解三元運算子，或寫起來很卡的話，也可以先用最簡易的 if else 來寫，然後再慢慢對照三元運算的概念。以下取庫存增加的 function 來做範例：\njs// 庫存增加\nconst handleQtyAdd = (id) =&gt; &#123;\n  const menuTemp = menu.map((item) =&gt; &#123;\n    if(item.id === id) &#123;\n      return &#123;\n        ...item, \n        qty: (item.qty += 1)\n      &#125;\n    &#125; else &#123;\n      return item;\n    &#125;\n\n    // return item.id === id \n    //   ? &#123; ...item, qty: (item.qty += 1) &#125; \n    //   : item;\n  &#125;);\n  setMenu(menuTemp);\n&#125;庫存數量優化因為庫存數量增減的 function 只有差異在 item.qty += 1 跟 item.qty -= 1，所以把增減的兩個 function 縮減成一個，然後多傳入一個參數（type) 作為增減的判斷。\njsconst &#123; useState &#125; = React;\n\nconst drinkMenu = [\n  // 略 ...\n];\n\nfunction MenuManage() &#123;\n  // Hooks 資料定義\n  const [menu, setMenu] = useState(drinkMenu);\n  \n  // 庫存數量功能\n  const handleQtyFn = (id, type) =&gt; &#123;\n    const menuTemp = menu.map((item) =&gt; &#123;\n      return item.id === id \n        ? &#123; ...item, qty: type === &#39;add&#39; ? (item.qty += 1) : (item.qty -= 1) &#125; \n        : item;\n    &#125;);\n    setMenu(menuTemp);\n  &#125;\n  \n  return (\n    &lt;div className=&quot;container&quot;&gt;\n      &lt;h1&gt;餐點管理工具&lt;/h1&gt;\n      &lt;table&gt;\n        // 略 ...\n        &lt;tbody&gt;\n          &#123;\n            menu.map((item) =&gt; &#123;\n              return (\n                &lt;tr key=&#123;item.id&#125;&gt;\n                  // 略...\n                  &lt;td&gt;\n                    &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleQtyFn(item.id, &#39;minus&#39;)&#125;&gt;-&lt;/button&gt;\n                    &#123;item.qty&#125;\n                    &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleQtyFn(item.id, &#39;add&#39;)&#125;&gt;+&lt;/button&gt;\n                  &lt;/td&gt;\n                &lt;/tr&gt; \n              )\n            &#125;)\n          &#125;\n        &lt;/tbody&gt;  \n      &lt;/table&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));\nroot.render(&lt;MenuManage /&gt;);\n\n編輯品項名稱這個部分剛開始有卡關一陣，主要是定義 state 資料所產生的問題。在編輯品項中，剛開始的粗淺想法是增加一個 boolen state 來做判斷 （像是：const [status, setStatus] = useState(true)），不過這樣的方式無法去識別點編輯的項目是哪一個，例如對某個品項點擊編輯，會發現全部品項都可以編譯。\n後來改用定義 id（const [currentId, setCurrentId] = useState(&#39;&#39;)）的方式為依據。流程大致是：在初始狀態 currentId 為空值時，每個餐點項目都是顯示”品項名稱”跟”編輯按鈕”；假設第二個品項中的編輯按鈕被點擊時，就會透過 handleCurrentId 以及第二個品項的 item.id 參數去做 setCurrentId，此時在樣板的 item.id === currentId 判斷中，第二個品項就會顯示 “input” 跟”完成按鈕”。\n(至於 input 的 onChange，邏輯上跟前面庫存的寫法一致，所以就不再贅述。)\njsconst &#123; useState &#125; = React;\n\nconst drinkMenu = [\n  // 略 ...\n];\n\nfunction MenuManage() &#123;\n  // Hooks 資料定義\n  const [menu, setMenu] = useState(drinkMenu);\n  const [currentId, setCurrentId] = useState(&#39;&#39;);\n  \n  // 略...\n  \n  const handleCurrentId = (id, type) =&gt; &#123;\n    type === &#39;edit&#39; ? setCurrentId(id) : setCurrentId(&#39;&#39;);\n  &#125;\n  \n  // input \n  const handleChangeInput = (e, id) =&gt; &#123;\n    const menuTemp = menu.map((item) =&gt; &#123;\n      return item.id === id \n        ? &#123; ...item, name: e.target.value &#125; \n        : item;\n    &#125;);\n    setMenu(menuTemp);\n  &#125;\n\n  return (\n    &lt;div className=&quot;container&quot;&gt;\n      &lt;h1&gt;餐點管理工具&lt;/h1&gt;\n      &lt;table&gt;\n        // 略 ...\n        &lt;tbody&gt;\n          &#123;\n            menu.map((item) =&gt; &#123;\n              return (\n                &lt;tr key=&#123;item.id&#125;&gt;\n                  &lt;td&gt;\n                    &#123; \n                      item.id === currentId \n                      ? ( &lt;&gt;\n                            &lt;input type=&quot;text&quot; value=&#123;item.name&#125; onChange=&#123;(e) =&gt; handleChangeInput(e, item.id)&#125; /&gt;\n                            &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleCurrentId(item.id, &#39;complete&#39;)&#125;&gt;\n                              完成\n                            &lt;/button&gt; \n                          &lt;/&gt;\n                        )\n                      : ( \n                          &lt;&gt;\n                           &#123; item.name &#125;\n                            &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; handleCurrentId(item.id, &#39;edit&#39;)&#125;&gt;\n                              編輯\n                            &lt;/button&gt; \n                          &lt;/&gt;\n                        )\n                    &#125;\n                    \n                  &lt;/td&gt;\n                  // 略...\n                &lt;/tr&gt; \n              )\n            &#125;)\n          &#125;\n        &lt;/tbody&gt;  \n      &lt;/table&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));\nroot.render(&lt;MenuManage /&gt;);\n\n結尾實際在寫 React 的時候，還是能感受到自己原生 JS 功力比較弱，所以這樣的刻意練習，應該也是會有幫助的。另外如果有什麼部分或概念寫錯，也再麻煩指導，感謝！\n","slug":"react-workshop-week1","date":"2023-08-10T16:00:00.000Z","categories_index":"前端","tags_index":"六角學院,React","author_index":"Billy's blog"},{"id":"472aaf59ccd0eb0fa1162d37a0fce187","title":"選擇用 Obsidian","content":"\n\n\n前言之前都是用 Notion 來做筆記和生活紀錄，不過一直隱約覺得「注意力容易發散」，也覺察到自己如果很需要專注時，反而會下意識使用紙筆或 Hackmd。後來在探索跟看一些使用者的筆記軟體心得時，意會到了自己很容易分心在 Notion 強大的功能跟排版上，所以對我來說這種強大的功能反而變成枷鎖。( 也覺得一些 Notion 精通者很厲害，我之前常常被連來連去跟資料庫相關弄得很頭大 )\n跳到 Obsidian研究了筆記軟體一陣子後，決定跳到 Obsidian ，雖然使用時間沒有很久，也只略略了解關聯圖跟卡片筆記的概念，但目前使用的專注度還算不錯 ( 注意力不會發散 )。對我來說的優點：\n\n比較容易專注。( 個人主觀 )\n需要的功能再漸進式裝上外掛即可。( 目前也只裝了 git 跟日曆 )\n檔案是歸自己本地端所管理，所以不用連上網路也可以寫作跟筆記。\n如果需要備份到雲端，可以在 github 開個儲存庫搭配 Obsidian Git。( 需要會 git 語法 )\n\n工具順手就好以上為個人主觀經驗分享，用意不在工具的好壞之分。也許有一些人用 Notion 可以相當專注、順手，也可能有些人用陽春的記事本就能達成目標。而不論什麼軟體都是個工具(解決問題)，最主要的還是用起來順手、感受不錯、大腦如何構築流程。\n","slug":"select-obsidian","date":"2023-04-04T16:00:00.000Z","categories_index":"生活","tags_index":"生活","author_index":"Billy's blog"},{"id":"7417496b7729d15c99c8ff46f9d0cb52","title":"回憶錄：小四的那一年","content":"\n\n前言 - 為何會有這篇文小學四年級時，曾在嘉義過溝短暫待了一年。而前天早晨夢到了相關的人事物，起床後忽然很好奇那邊現在的景象，所以就用了 google map 的街景服務，不過自己並沒有記得當初的住址，所以就以曾經待過的國小“過溝國小”跟“兩週一次的夜市”作為關鍵字。一直覺得記憶力不太可靠，但在這次的搜尋中，也看到了記憶力驚奇的一面。在關鍵字拼湊後，我找到了“過溝建德宮”，這是那一年很常去的地點，然後透過 google map 的街景服務，我居然還記得怎麼從這座廟宇走回當初的住處。 看著這些有點熟悉又有點陌生的場景，回憶也開始湧現，並且想把這些回憶紀錄下來。\n回憶小時候因為家裡是做生意的，所以很常搬家，大概到了高中之後才沒有再變動。所以在成長背景中算是被迫認識新環境，有時也會對於不斷分離有一些感傷，不過隨著年紀的增長，也會開始壓抑住這種心情，可能是刻板教育教我們的：「男孩子不能隨便哭」。如同前言所述，小學四年級時在嘉義過溝待了一年。記得以前父母就一直說這裡真的很偏僻；但我是滿喜歡這裡的，即使現在回想起來也是相同感覺。\n\n如上方圖片所示，這是在 googla map 中截圖的，那時就住在右邊的鐵皮屋，如果颱風來的時候，則會產生滿驚人的聲響。周遭附近滿特別的是都會有大水溝，以前打躲避球的時候，都要很小心不讓球掉進去，因為撿起來真的很麻煩，有些時候我們也會在水溝放水鴛鴦之類。講到這個大水溝，也還有一件印象深刻的事：有一次颱風來時，父母一直在家裡聽到旁邊水溝有小狗的叫聲，冒著風雨到外頭，發現有好幾隻很小的小狗掉下去，後來有把牠們都救了出來。不過不曉得為什麼，我只有後來的印象，就是騎著菜籃腳踏車把小狗們，送到可以養的人家，中途小狗還會自己跳車，真的是有點驚險！\n記得這個時期，我們兄弟就已經開始幫忙家裡包裝衣服，雖然有時候都會心不甘情不願的。除了幫忙之外，在履行學生必要作業後，就會跟弟弟或同學、鄰居騎著單車到處亂跑，這也可能是為何我現在還能透過 google map 街景，從廟宇走到當初住家的原因吧！那時會到處亂跑，在周遭的穿梭上幾乎不太需注意太多，除了打躲避球要注意一下水溝之外，以及偶爾的來車。主要的活動有：騎單車、聊天、打躲避球、槍戰與橡皮筋互射、彈珠、遊戲王卡，偶爾會踢一下毽子。然後自誇一下，那時候我自己一個人會打羽球（運球），然後到最後可以到好幾百下，不曉得跟後來的球感有沒有關係 XD\n這裡雖然算是滿鄉下的，但還是會有一些時間點比較熱鬧，就是鋼管舞跟隔週六的小夜市。不過以小學生的年紀來說，對於鋼管舞是根本沒興趣的，只有印象一些阿伯、老人家會坐在那邊看。\n\n隔週六的夜市就在過溝建德宮，記得以前也滿常過去的，都會跟父母拿一些零錢買點東西吃，也是旁邊雜貨店的常客，好像都會去買飲料跟上廁所，買到都會認識老闆（or 店員）。小插曲的話，就是曾經遇到一個老人家，估計是腦袋怪怪的那種，在我從雜貨店出來後，就拉著我的耳朵一直罵我，但他口音實在太重，所以根本不曉得在講什麼，不過後來也忘記自己是怎麼應對的？\n從 google map 看到學校內的圖片，沒有想到自己還有些微印象，尤其是教室後頭，如果沒記錯的話有個停腳踏車的棚子。以前跟一個比較要好的女同學，也滿常下課時在這邊聊天，當然很常在一起聊天，鐵定是會被同學起鬨的，至於小學生的起鬨模式大概就是那個樣子了 XD除了開心的聊天，也想起國文課寫作文的有趣情形，我們在寫作文都屬於文思泉湧的類型，速度很快且不是亂寫的那種，都是班上前幾個交卷，拿到的評分都還算不錯。那時都會想寫的比她更快，所以都會在家偷讀“小學生作文範本”之類的書。（文思泉湧技能隨著年齡增長而遞減QQ…）如果沒有記錯的話，她的個性也滿直率、活潑，家裡住在三合院，媽媽是滿嚴格（兇）。在要搬家的那個暑假前，也收到她寫的信，因為是第一次收到這種信，所以也珍惜的保存許久……。那個暑假得知要搬家後，比較遺憾的地方就是沒有跟她道別，記得在搬家前有好幾次走到她家附近，想說看看能不能碰見她，但實在不敢走進去，好像是考量到她會被罵。（還好那時是小孩子，如果是現在年紀鐵定被當變態叔叔）（後續她從卡納赫拉社團來相認，我真的非常驚訝，腦袋還當機了一段時間，畢竟經過了將近 20 年）\n最後一天與結尾在嘉義過溝要搬家離開的那一天，在家裡車子剛開走的後方鏡子中，看到一群來找我的同學跟朋友（記得滿大團的），他們騎著腳踏車在後面追著，印象是滿深刻的。不過氣氛不是那種感傷分別電影，而比較像在玩樂的追著。\n雖然只在那邊待過一年，但對我來說是很開心的，充滿著許多體驗，這些回憶如同我的個人寶藏一般。我不太確定，之後還會不會有這樣的靈光一閃，以及許久不見的文思泉湧。就趁著還能回憶起來的時候，記錄下來吧！\n2023.02.22補：其實這篇文章在一個多月前就寫好了，因為生活中持續有些要探索的，礙於身體跟時間都有限，就暫時擱置上這篇文章。補上這篇文的當下，也了解到“小學四年級”對我來說是一個“分界線”，開始變得彆扭、沒那麼自在的分界線。\n","slug":"memoirs-child-chiayi","date":"2023-02-21T16:00:00.000Z","categories_index":"生活","tags_index":"生活","author_index":"Billy's blog"},{"id":"7d5f6baee0825b123312862f0e99bd04","title":"刻骨銘心的 2022","content":"2022 也即將踏上尾聲，如果要我對 2022 下一些關鍵字的話，我會選擇「痛苦」、「爭執」、「覺察」、「掙扎」、「疑難雜症」等這五組字詞。\n在去年年底時，因擔心影響到工作，所以本來沒有打Ｘ苗的打算，也決定先打一劑試試，而沒想到這一個決定會影響到至今，以我寫文的這個當下，快滿週年了（週年慶先不要，拜託了）。\n打了Ｘ苗後在診所外休息，正當感覺到不太舒服時就昏了過去。醒來後在診所休息了一陣，因為昏倒時有撞到頭，所以也到鄰近的大醫院檢查，所幸檢查結果沒有大礙。不過這段經歷也是相當不舒服的，在檢查候診、醫生觀察的同時，我也不斷領受著畏寒的副作用。（還好打苗的時候，有請太太陪同）\n爾後就開始了這趟身體不適之旅（討厭的旅途），一月中的某一天忽然覺得很不舒服，擔心會不會是心肌炎，不過去大醫院檢查心臟的結果是一切正常，我也忘不了那個醫生疑惑的表情，他應該是在想說：「為何這個年輕人只有微微發燒，卻無力到需要被用輪椅推著……。」\n在一月底到三月底這段時間，是還能出門上班的，也還好二月假期比較多，算是很大的分擔與緩解，讓身體可以抓緊時間多休息。而這段期間的後期，身體也有持續再恢復著，生活、工作上也越來越接近健康狀態；不過好景不長，接近三月底之前的某一天，又開始覺得身體渾身不對勁，莫名的不舒服感又再度來襲，整體狀況也掉得很快，我知道我的狀態應該暫時回不來了，也正式無法工作了。\n三月底無法工作，而四月底左右時，衡量了彼此的整體狀況，跟太太提議暫時回彼此的家裡（分居），大概一到兩週時再聚個一次。\n當時的症狀有：\n\n心悸\n胃脹氣\n疲倦無力\n莫名不舒服\n莫名不安（恐慌感）\n害怕出門\n\n直到現在，有些症狀已經減輕或消失，有些還努力調養中。這麼多症狀，還涵蓋了身體與心理（恐慌、害怕出門），如果在西醫的角度上，就會被診斷為「自律神經失調」；而以中醫的角度，就會用「疑難雜症」來形容。（個人主觀偏好用後者，不過並沒有想戰什麼XD）\n\n近期回顧這段時間的日記，發現自己從今年的前期到寫這文章的當下，一直都想知道為什麼？身體發生了什麼事？找答案的過程中，主要是以中醫作為調理，然後自己跳下來研究很多範疇：X苗副作用、自然醫學、斷食、營養品、恐慌症、中醫等等。而最近幾個月就比較限縮在中醫知識了，一來是自己的偏好，二來是中醫本身的概念涵蓋較廣（全人、身心一體）；不過到目前都沒拼湊出什麼蛛絲馬跡，期望總有一天能知道些什麼。現在就先對自己說：「這就是人生苦澀體驗……」\n這段過程除了研究外，也盡力調整作息與心情，嘗試了營養品（GABA、CBD、南非醉茄…），然後也到廟裡求神問事、收驚，以及人生第一次的催眠等等。有些故事也留待之後再來說了（如果有想起來的話）。\n除了本身的病痛外，心理上的調整也讓我覺得很不容易，加上不能自主自在的出門，所以也少了很多的抒發管道。過去在心情煩悶時，還能去健身房舉舉重量，到操場跑一跑，出外逛街、找個地方喝咖啡……等等；不過現在都無法了，取而代之的是：自己面對自己的時間，在日常生活中（尤其夜深人靜時），更能觸碰到自己的想法與情緒，看著大腦不斷反芻著過去，然後焦慮的想像未來場景。而不論過去或未來，對於現在這個此刻來說都不是真實的；不過卻像我們在看電影一樣，很容易就被拉入劇情中，尤其是負面的劇情。\n這段時間經歷了很多劇本，像是“自己和自己過意不去”、“和周遭進行價值觀的爭執（簡單來說就是吵架）”、以及“社會對我的評價（簡單來說就是會被評價、攻擊）”。而有些情景也歷歷在目，像是五月、六月晚上寫日記時，因為有著太多負面情緒，差點把日記本撕爛；或者在爭執後，拖著疲倦的身軀體會著低潮，想著：「到底是要我怎麼樣？我還能怎麼辦呢？」，以及低潮時腦海的喃喃自語：「這樣的痛苦何時會消失呢？如果沒去打那針就好了……」\n雖然乘載了許多負面，但很幸運的在這過程中也遇到幾位貴人幫助，引導我去接觸正念冥想，指出我個性、習慣可以調整的部分，建議我可以去看什麼書籍，在這難熬的時間陪我聊天，給予我心理上的支持。讓我的心情從「死死卡快活」轉變到「**即使難看的掙扎著，我也要做好現在能做的事情……**」。\n感謝家人、醫生們、好友、催眠師、收驚老師、公司老闆及同事、新認識的朋友，這些恩情我會記在心裡的。\nPhoto by Kelly Sikkema on Unsplash\n","slug":"unforgettable-2022","date":"2022-12-22T16:00:00.000Z","categories_index":"生活","tags_index":"生活","author_index":"Billy's blog"}]